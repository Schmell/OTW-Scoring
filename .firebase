commit 6f8e5c79c7ce9a3ac16666a0c4a150258f663762
Author: Schmell Mafeet <schmell_ya_later@hotmail.com>
Date:   Tue Sep 6 14:37:05 2022 -0400

    vite is working

diff --git a/dev-dist/registerSW.js b/dev-dist/registerSW.js
new file mode 100644
index 0000000..1d5625f
--- /dev/null
+++ b/dev-dist/registerSW.js
@@ -0,0 +1 @@
+if('serviceWorker' in navigator) navigator.serviceWorker.register('/dev-sw.js?dev-sw', { scope: '/', type: 'classic' })
\ No newline at end of file
diff --git a/dev-dist/sw.js b/dev-dist/sw.js
new file mode 100644
index 0000000..2429cc9
--- /dev/null
+++ b/dev-dist/sw.js
@@ -0,0 +1,104 @@
+/**
+ * Copyright 2018 Google Inc. All Rights Reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// If the loader is already loaded, just stop.
+if (!self.define) {
+  let registry = {};
+
+  // Used for `eval` and `importScripts` where we can't get script URL by other means.
+  // In both cases, it's safe to use a global var because those functions are synchronous.
+  let nextDefineUri;
+
+  const singleRequire = (uri, parentUri) => {
+    uri = new URL(uri + ".js", parentUri).href;
+    return registry[uri] || (
+      
+        new Promise(resolve => {
+          if ("document" in self) {
+            const script = document.createElement("script");
+            script.src = uri;
+            script.onload = resolve;
+            document.head.appendChild(script);
+          } else {
+            nextDefineUri = uri;
+            importScripts(uri);
+            resolve();
+          }
+        })
+      
+      .then(() => {
+        let promise = registry[uri];
+        if (!promise) {
+          throw new Error(`Module ${uri} didnâ€™t register its module`);
+        }
+        return promise;
+      })
+    );
+  };
+
+  self.define = (depsNames, factory) => {
+    const uri = nextDefineUri || ("document" in self ? document.currentScript.src : "") || location.href;
+    if (registry[uri]) {
+      // Module is already loading or loaded.
+      return;
+    }
+    let exports = {};
+    const require = depUri => singleRequire(depUri, uri);
+    const specialDeps = {
+      module: { uri },
+      exports,
+      require
+    };
+    registry[uri] = Promise.all(depsNames.map(
+      depName => specialDeps[depName] || require(depName)
+    )).then(deps => {
+      factory(...deps);
+      return exports;
+    });
+  };
+}
+define(['./workbox-3589c0c5'], (function (workbox) { 'use strict';
+
+  /**
+  * Welcome to your Workbox-powered service worker!
+  *
+  * You'll need to register this file in your web app.
+  * See https://goo.gl/nhQhGp
+  *
+  * The rest of the code is auto-generated. Please don't update this file
+  * directly; instead, make changes to your Workbox build configuration
+  * and re-run your build process.
+  * See https://goo.gl/2aRDsh
+  */
+
+  self.skipWaiting();
+  workbox.clientsClaim();
+  /**
+   * The precacheAndRoute() method efficiently caches and responds to
+   * requests for URLs in the manifest.
+   * See https://goo.gl/S9QRab
+   */
+
+  workbox.precacheAndRoute([{
+    "url": "registerSW.js",
+    "revision": "3ca0b8505b4bec776b69afdba2768812"
+  }, {
+    "revision": null,
+    "url": "index.html"
+  }], {});
+  workbox.cleanupOutdatedCaches();
+  workbox.registerRoute(new workbox.NavigationRoute(workbox.createHandlerBoundToURL("index.html"), {
+    allowlist: [/^\/$/]
+  }));
+
+}));
diff --git a/dev-dist/workbox-3589c0c5.js b/dev-dist/workbox-3589c0c5.js
new file mode 100644
index 0000000..ff487c2
--- /dev/null
+++ b/dev-dist/workbox-3589c0c5.js
@@ -0,0 +1,3787 @@
+define(['exports'], (function (exports) { 'use strict';
+
+    try {
+      self['workbox:core:6.5.3'] && _();
+    } catch (e) {}
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Claim any currently available clients once the service worker
+     * becomes active. This is normally used in conjunction with `skipWaiting()`.
+     *
+     * @memberof workbox-core
+     */
+
+    function clientsClaim() {
+      self.addEventListener('activate', () => self.clients.claim());
+    }
+
+    /*
+      Copyright 2019 Google LLC
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    const logger = (() => {
+      // Don't overwrite this value if it's already set.
+      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
+      if (!('__WB_DISABLE_DEV_LOGS' in self)) {
+        self.__WB_DISABLE_DEV_LOGS = false;
+      }
+
+      let inGroup = false;
+      const methodToColorMap = {
+        debug: `#7f8c8d`,
+        log: `#2ecc71`,
+        warn: `#f39c12`,
+        error: `#c0392b`,
+        groupCollapsed: `#3498db`,
+        groupEnd: null // No colored prefix on groupEnd
+
+      };
+
+      const print = function (method, args) {
+        if (self.__WB_DISABLE_DEV_LOGS) {
+          return;
+        }
+
+        if (method === 'groupCollapsed') {
+          // Safari doesn't print all console.groupCollapsed() arguments:
+          // https://bugs.webkit.org/show_bug.cgi?id=182754
+          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
+            console[method](...args);
+            return;
+          }
+        }
+
+        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`]; // When in a group, the workbox prefix is not displayed.
+
+        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
+        console[method](...logPrefix, ...args);
+
+        if (method === 'groupCollapsed') {
+          inGroup = true;
+        }
+
+        if (method === 'groupEnd') {
+          inGroup = false;
+        }
+      }; // eslint-disable-next-line @typescript-eslint/ban-types
+
+
+      const api = {};
+      const loggerMethods = Object.keys(methodToColorMap);
+
+      for (const key of loggerMethods) {
+        const method = key;
+
+        api[method] = (...args) => {
+          print(method, args);
+        };
+      }
+
+      return api;
+    })();
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    const messages = {
+      'invalid-value': ({
+        paramName,
+        validValueDescription,
+        value
+      }) => {
+        if (!paramName || !validValueDescription) {
+          throw new Error(`Unexpected input to 'invalid-value' error.`);
+        }
+
+        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;
+      },
+      'not-an-array': ({
+        moduleName,
+        className,
+        funcName,
+        paramName
+      }) => {
+        if (!moduleName || !className || !funcName || !paramName) {
+          throw new Error(`Unexpected input to 'not-an-array' error.`);
+        }
+
+        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;
+      },
+      'incorrect-type': ({
+        expectedType,
+        paramName,
+        moduleName,
+        className,
+        funcName
+      }) => {
+        if (!expectedType || !paramName || !moduleName || !funcName) {
+          throw new Error(`Unexpected input to 'incorrect-type' error.`);
+        }
+
+        const classNameStr = className ? `${className}.` : '';
+        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;
+      },
+      'incorrect-class': ({
+        expectedClassName,
+        paramName,
+        moduleName,
+        className,
+        funcName,
+        isReturnValueProblem
+      }) => {
+        if (!expectedClassName || !moduleName || !funcName) {
+          throw new Error(`Unexpected input to 'incorrect-class' error.`);
+        }
+
+        const classNameStr = className ? `${className}.` : '';
+
+        if (isReturnValueProblem) {
+          return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
+        }
+
+        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
+      },
+      'missing-a-method': ({
+        expectedMethod,
+        paramName,
+        moduleName,
+        className,
+        funcName
+      }) => {
+        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {
+          throw new Error(`Unexpected input to 'missing-a-method' error.`);
+        }
+
+        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
+      },
+      'add-to-cache-list-unexpected-type': ({
+        entry
+      }) => {
+        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;
+      },
+      'add-to-cache-list-conflicting-entries': ({
+        firstEntry,
+        secondEntry
+      }) => {
+        if (!firstEntry || !secondEntry) {
+          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);
+        }
+
+        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;
+      },
+      'plugin-error-request-will-fetch': ({
+        thrownErrorMessage
+      }) => {
+        if (!thrownErrorMessage) {
+          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);
+        }
+
+        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;
+      },
+      'invalid-cache-name': ({
+        cacheNameId,
+        value
+      }) => {
+        if (!cacheNameId) {
+          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
+        }
+
+        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;
+      },
+      'unregister-route-but-not-found-with-method': ({
+        method
+      }) => {
+        if (!method) {
+          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);
+        }
+
+        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;
+      },
+      'unregister-route-route-not-registered': () => {
+        return `The route you're trying to unregister was not previously ` + `registered.`;
+      },
+      'queue-replay-failed': ({
+        name
+      }) => {
+        return `Replaying the background sync queue '${name}' failed.`;
+      },
+      'duplicate-queue-name': ({
+        name
+      }) => {
+        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;
+      },
+      'expired-test-without-max-age': ({
+        methodName,
+        paramName
+      }) => {
+        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;
+      },
+      'unsupported-route-type': ({
+        moduleName,
+        className,
+        funcName,
+        paramName
+      }) => {
+        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;
+      },
+      'not-array-of-class': ({
+        value,
+        expectedClass,
+        moduleName,
+        className,
+        funcName,
+        paramName
+      }) => {
+        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;
+      },
+      'max-entries-or-age-required': ({
+        moduleName,
+        className,
+        funcName
+      }) => {
+        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;
+      },
+      'statuses-or-headers-required': ({
+        moduleName,
+        className,
+        funcName
+      }) => {
+        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;
+      },
+      'invalid-string': ({
+        moduleName,
+        funcName,
+        paramName
+      }) => {
+        if (!paramName || !moduleName || !funcName) {
+          throw new Error(`Unexpected input to 'invalid-string' error.`);
+        }
+
+        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;
+      },
+      'channel-name-required': () => {
+        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;
+      },
+      'invalid-responses-are-same-args': () => {
+        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;
+      },
+      'expire-custom-caches-only': () => {
+        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;
+      },
+      'unit-must-be-bytes': ({
+        normalizedRangeHeader
+      }) => {
+        if (!normalizedRangeHeader) {
+          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
+        }
+
+        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was "${normalizedRangeHeader}"`;
+      },
+      'single-range-only': ({
+        normalizedRangeHeader
+      }) => {
+        if (!normalizedRangeHeader) {
+          throw new Error(`Unexpected input to 'single-range-only' error.`);
+        }
+
+        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `"${normalizedRangeHeader}"`;
+      },
+      'invalid-range-values': ({
+        normalizedRangeHeader
+      }) => {
+        if (!normalizedRangeHeader) {
+          throw new Error(`Unexpected input to 'invalid-range-values' error.`);
+        }
+
+        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `"${normalizedRangeHeader}"`;
+      },
+      'no-range-header': () => {
+        return `No Range header was found in the Request provided.`;
+      },
+      'range-not-satisfiable': ({
+        size,
+        start,
+        end
+      }) => {
+        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;
+      },
+      'attempt-to-cache-non-get-request': ({
+        url,
+        method
+      }) => {
+        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;
+      },
+      'cache-put-with-no-response': ({
+        url
+      }) => {
+        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;
+      },
+      'no-response': ({
+        url,
+        error
+      }) => {
+        let message = `The strategy could not generate a response for '${url}'.`;
+
+        if (error) {
+          message += ` The underlying error is ${error}.`;
+        }
+
+        return message;
+      },
+      'bad-precaching-response': ({
+        url,
+        status
+      }) => {
+        return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);
+      },
+      'non-precached-url': ({
+        url
+      }) => {
+        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;
+      },
+      'add-to-cache-list-conflicting-integrities': ({
+        url
+      }) => {
+        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;
+      },
+      'missing-precache-entry': ({
+        cacheName,
+        url
+      }) => {
+        return `Unable to find a precached response in ${cacheName} for ${url}.`;
+      },
+      'cross-origin-copy-response': ({
+        origin
+      }) => {
+        return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;
+      },
+      'opaque-streams-source': ({
+        type
+      }) => {
+        const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;
+
+        if (type === 'opaqueredirect') {
+          return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;
+        }
+
+        return `${message} Please ensure your sources are CORS-enabled.`;
+      }
+    };
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+
+    const generatorFunction = (code, details = {}) => {
+      const message = messages[code];
+
+      if (!message) {
+        throw new Error(`Unable to find message for code '${code}'.`);
+      }
+
+      return message(details);
+    };
+
+    const messageGenerator = generatorFunction;
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Workbox errors should be thrown with this class.
+     * This allows use to ensure the type easily in tests,
+     * helps developers identify errors from workbox
+     * easily and allows use to optimise error
+     * messages correctly.
+     *
+     * @private
+     */
+
+    class WorkboxError extends Error {
+      /**
+       *
+       * @param {string} errorCode The error code that
+       * identifies this particular error.
+       * @param {Object=} details Any relevant arguments
+       * that will help developers identify issues should
+       * be added as a key on the context object.
+       */
+      constructor(errorCode, details) {
+        const message = messageGenerator(errorCode, details);
+        super(message);
+        this.name = errorCode;
+        this.details = details;
+      }
+
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /*
+     * This method throws if the supplied value is not an array.
+     * The destructed values are required to produce a meaningful error for users.
+     * The destructed and restructured object is so it's clear what is
+     * needed.
+     */
+
+    const isArray = (value, details) => {
+      if (!Array.isArray(value)) {
+        throw new WorkboxError('not-an-array', details);
+      }
+    };
+
+    const hasMethod = (object, expectedMethod, details) => {
+      const type = typeof object[expectedMethod];
+
+      if (type !== 'function') {
+        details['expectedMethod'] = expectedMethod;
+        throw new WorkboxError('missing-a-method', details);
+      }
+    };
+
+    const isType = (object, expectedType, details) => {
+      if (typeof object !== expectedType) {
+        details['expectedType'] = expectedType;
+        throw new WorkboxError('incorrect-type', details);
+      }
+    };
+
+    const isInstance = (object, // Need the general type to do the check later.
+    // eslint-disable-next-line @typescript-eslint/ban-types
+    expectedClass, details) => {
+      if (!(object instanceof expectedClass)) {
+        details['expectedClassName'] = expectedClass.name;
+        throw new WorkboxError('incorrect-class', details);
+      }
+    };
+
+    const isOneOf = (value, validValues, details) => {
+      if (!validValues.includes(value)) {
+        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;
+        throw new WorkboxError('invalid-value', details);
+      }
+    };
+
+    const isArrayOfClass = (value, // Need general type to do check later.
+    expectedClass, // eslint-disable-line
+    details) => {
+      const error = new WorkboxError('not-array-of-class', details);
+
+      if (!Array.isArray(value)) {
+        throw error;
+      }
+
+      for (const item of value) {
+        if (!(item instanceof expectedClass)) {
+          throw error;
+        }
+      }
+    };
+
+    const finalAssertExports = {
+      hasMethod,
+      isArray,
+      isInstance,
+      isOneOf,
+      isType,
+      isArrayOfClass
+    };
+
+    try {
+      self['workbox:routing:6.5.3'] && _();
+    } catch (e) {}
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * The default HTTP method, 'GET', used when there's no specific method
+     * configured for a route.
+     *
+     * @type {string}
+     *
+     * @private
+     */
+
+    const defaultMethod = 'GET';
+    /**
+     * The list of valid HTTP methods associated with requests that could be routed.
+     *
+     * @type {Array<string>}
+     *
+     * @private
+     */
+
+    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * @param {function()|Object} handler Either a function, or an object with a
+     * 'handle' method.
+     * @return {Object} An object with a handle method.
+     *
+     * @private
+     */
+
+    const normalizeHandler = handler => {
+      if (handler && typeof handler === 'object') {
+        {
+          finalAssertExports.hasMethod(handler, 'handle', {
+            moduleName: 'workbox-routing',
+            className: 'Route',
+            funcName: 'constructor',
+            paramName: 'handler'
+          });
+        }
+
+        return handler;
+      } else {
+        {
+          finalAssertExports.isType(handler, 'function', {
+            moduleName: 'workbox-routing',
+            className: 'Route',
+            funcName: 'constructor',
+            paramName: 'handler'
+          });
+        }
+
+        return {
+          handle: handler
+        };
+      }
+    };
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * A `Route` consists of a pair of callback functions, "match" and "handler".
+     * The "match" callback determine if a route should be used to "handle" a
+     * request by returning a non-falsy value if it can. The "handler" callback
+     * is called when there is a match and should return a Promise that resolves
+     * to a `Response`.
+     *
+     * @memberof workbox-routing
+     */
+
+    class Route {
+      /**
+       * Constructor for Route class.
+       *
+       * @param {workbox-routing~matchCallback} match
+       * A callback function that determines whether the route matches a given
+       * `fetch` event by returning a non-falsy value.
+       * @param {workbox-routing~handlerCallback} handler A callback
+       * function that returns a Promise resolving to a Response.
+       * @param {string} [method='GET'] The HTTP method to match the Route
+       * against.
+       */
+      constructor(match, handler, method = defaultMethod) {
+        {
+          finalAssertExports.isType(match, 'function', {
+            moduleName: 'workbox-routing',
+            className: 'Route',
+            funcName: 'constructor',
+            paramName: 'match'
+          });
+
+          if (method) {
+            finalAssertExports.isOneOf(method, validMethods, {
+              paramName: 'method'
+            });
+          }
+        } // These values are referenced directly by Router so cannot be
+        // altered by minificaton.
+
+
+        this.handler = normalizeHandler(handler);
+        this.match = match;
+        this.method = method;
+      }
+      /**
+       *
+       * @param {workbox-routing-handlerCallback} handler A callback
+       * function that returns a Promise resolving to a Response
+       */
+
+
+      setCatchHandler(handler) {
+        this.catchHandler = normalizeHandler(handler);
+      }
+
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * RegExpRoute makes it easy to create a regular expression based
+     * {@link workbox-routing.Route}.
+     *
+     * For same-origin requests the RegExp only needs to match part of the URL. For
+     * requests against third-party servers, you must define a RegExp that matches
+     * the start of the URL.
+     *
+     * @memberof workbox-routing
+     * @extends workbox-routing.Route
+     */
+
+    class RegExpRoute extends Route {
+      /**
+       * If the regular expression contains
+       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
+       * the captured values will be passed to the
+       * {@link workbox-routing~handlerCallback} `params`
+       * argument.
+       *
+       * @param {RegExp} regExp The regular expression to match against URLs.
+       * @param {workbox-routing~handlerCallback} handler A callback
+       * function that returns a Promise resulting in a Response.
+       * @param {string} [method='GET'] The HTTP method to match the Route
+       * against.
+       */
+      constructor(regExp, handler, method) {
+        {
+          finalAssertExports.isInstance(regExp, RegExp, {
+            moduleName: 'workbox-routing',
+            className: 'RegExpRoute',
+            funcName: 'constructor',
+            paramName: 'pattern'
+          });
+        }
+
+        const match = ({
+          url
+        }) => {
+          const result = regExp.exec(url.href); // Return immediately if there's no match.
+
+          if (!result) {
+            return;
+          } // Require that the match start at the first character in the URL string
+          // if it's a cross-origin request.
+          // See https://github.com/GoogleChrome/workbox/issues/281 for the context
+          // behind this behavior.
+
+
+          if (url.origin !== location.origin && result.index !== 0) {
+            {
+              logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);
+            }
+
+            return;
+          } // If the route matches, but there aren't any capture groups defined, then
+          // this will return [], which is truthy and therefore sufficient to
+          // indicate a match.
+          // If there are capture groups, then it will return their values.
+
+
+          return result.slice(1);
+        };
+
+        super(match, handler, method);
+      }
+
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+
+    const getFriendlyURL = url => {
+      const urlObj = new URL(String(url), location.href); // See https://github.com/GoogleChrome/workbox/issues/2323
+      // We want to include everything, except for the origin if it's same-origin.
+
+      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
+    };
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * The Router can be used to process a `FetchEvent` using one or more
+     * {@link workbox-routing.Route}, responding with a `Response` if
+     * a matching route exists.
+     *
+     * If no route matches a given a request, the Router will use a "default"
+     * handler if one is defined.
+     *
+     * Should the matching Route throw an error, the Router will use a "catch"
+     * handler if one is defined to gracefully deal with issues and respond with a
+     * Request.
+     *
+     * If a request matches multiple routes, the **earliest** registered route will
+     * be used to respond to the request.
+     *
+     * @memberof workbox-routing
+     */
+
+    class Router {
+      /**
+       * Initializes a new Router.
+       */
+      constructor() {
+        this._routes = new Map();
+        this._defaultHandlerMap = new Map();
+      }
+      /**
+       * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP
+       * method name ('GET', etc.) to an array of all the corresponding `Route`
+       * instances that are registered.
+       */
+
+
+      get routes() {
+        return this._routes;
+      }
+      /**
+       * Adds a fetch event listener to respond to events when a route matches
+       * the event's request.
+       */
+
+
+      addFetchListener() {
+        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
+        self.addEventListener('fetch', event => {
+          const {
+            request
+          } = event;
+          const responsePromise = this.handleRequest({
+            request,
+            event
+          });
+
+          if (responsePromise) {
+            event.respondWith(responsePromise);
+          }
+        });
+      }
+      /**
+       * Adds a message event listener for URLs to cache from the window.
+       * This is useful to cache resources loaded on the page prior to when the
+       * service worker started controlling it.
+       *
+       * The format of the message data sent from the window should be as follows.
+       * Where the `urlsToCache` array may consist of URL strings or an array of
+       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
+       *
+       * ```
+       * {
+       *   type: 'CACHE_URLS',
+       *   payload: {
+       *     urlsToCache: [
+       *       './script1.js',
+       *       './script2.js',
+       *       ['./script3.js', {mode: 'no-cors'}],
+       *     ],
+       *   },
+       * }
+       * ```
+       */
+
+
+      addCacheListener() {
+        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
+        self.addEventListener('message', event => {
+          // event.data is type 'any'
+          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
+          if (event.data && event.data.type === 'CACHE_URLS') {
+            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
+            const {
+              payload
+            } = event.data;
+
+            {
+              logger.debug(`Caching URLs from the window`, payload.urlsToCache);
+            }
+
+            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {
+              if (typeof entry === 'string') {
+                entry = [entry];
+              }
+
+              const request = new Request(...entry);
+              return this.handleRequest({
+                request,
+                event
+              }); // TODO(philipwalton): TypeScript errors without this typecast for
+              // some reason (probably a bug). The real type here should work but
+              // doesn't: `Array<Promise<Response> | undefined>`.
+            })); // TypeScript
+
+            event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.
+
+            if (event.ports && event.ports[0]) {
+              void requestPromises.then(() => event.ports[0].postMessage(true));
+            }
+          }
+        });
+      }
+      /**
+       * Apply the routing rules to a FetchEvent object to get a Response from an
+       * appropriate Route's handler.
+       *
+       * @param {Object} options
+       * @param {Request} options.request The request to handle.
+       * @param {ExtendableEvent} options.event The event that triggered the
+       *     request.
+       * @return {Promise<Response>|undefined} A promise is returned if a
+       *     registered route can handle the request. If there is no matching
+       *     route and there's no `defaultHandler`, `undefined` is returned.
+       */
+
+
+      handleRequest({
+        request,
+        event
+      }) {
+        {
+          finalAssertExports.isInstance(request, Request, {
+            moduleName: 'workbox-routing',
+            className: 'Router',
+            funcName: 'handleRequest',
+            paramName: 'options.request'
+          });
+        }
+
+        const url = new URL(request.url, location.href);
+
+        if (!url.protocol.startsWith('http')) {
+          {
+            logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
+          }
+
+          return;
+        }
+
+        const sameOrigin = url.origin === location.origin;
+        const {
+          params,
+          route
+        } = this.findMatchingRoute({
+          event,
+          request,
+          sameOrigin,
+          url
+        });
+        let handler = route && route.handler;
+        const debugMessages = [];
+
+        {
+          if (handler) {
+            debugMessages.push([`Found a route to handle this request:`, route]);
+
+            if (params) {
+              debugMessages.push([`Passing the following params to the route's handler:`, params]);
+            }
+          }
+        } // If we don't have a handler because there was no matching route, then
+        // fall back to defaultHandler if that's defined.
+
+
+        const method = request.method;
+
+        if (!handler && this._defaultHandlerMap.has(method)) {
+          {
+            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);
+          }
+
+          handler = this._defaultHandlerMap.get(method);
+        }
+
+        if (!handler) {
+          {
+            // No handler so Workbox will do nothing. If logs is set of debug
+            // i.e. verbose, we should print out this information.
+            logger.debug(`No route found for: ${getFriendlyURL(url)}`);
+          }
+
+          return;
+        }
+
+        {
+          // We have a handler, meaning Workbox is going to handle the route.
+          // print the routing details to the console.
+          logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
+          debugMessages.forEach(msg => {
+            if (Array.isArray(msg)) {
+              logger.log(...msg);
+            } else {
+              logger.log(msg);
+            }
+          });
+          logger.groupEnd();
+        } // Wrap in try and catch in case the handle method throws a synchronous
+        // error. It should still callback to the catch handler.
+
+
+        let responsePromise;
+
+        try {
+          responsePromise = handler.handle({
+            url,
+            request,
+            event,
+            params
+          });
+        } catch (err) {
+          responsePromise = Promise.reject(err);
+        } // Get route's catch handler, if it exists
+
+
+        const catchHandler = route && route.catchHandler;
+
+        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {
+          responsePromise = responsePromise.catch(async err => {
+            // If there's a route catch handler, process that first
+            if (catchHandler) {
+              {
+                // Still include URL here as it will be async from the console group
+                // and may not make sense without the URL
+                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);
+                logger.error(`Error thrown by:`, route);
+                logger.error(err);
+                logger.groupEnd();
+              }
+
+              try {
+                return await catchHandler.handle({
+                  url,
+                  request,
+                  event,
+                  params
+                });
+              } catch (catchErr) {
+                if (catchErr instanceof Error) {
+                  err = catchErr;
+                }
+              }
+            }
+
+            if (this._catchHandler) {
+              {
+                // Still include URL here as it will be async from the console group
+                // and may not make sense without the URL
+                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);
+                logger.error(`Error thrown by:`, route);
+                logger.error(err);
+                logger.groupEnd();
+              }
+
+              return this._catchHandler.handle({
+                url,
+                request,
+                event
+              });
+            }
+
+            throw err;
+          });
+        }
+
+        return responsePromise;
+      }
+      /**
+       * Checks a request and URL (and optionally an event) against the list of
+       * registered routes, and if there's a match, returns the corresponding
+       * route along with any params generated by the match.
+       *
+       * @param {Object} options
+       * @param {URL} options.url
+       * @param {boolean} options.sameOrigin The result of comparing `url.origin`
+       *     against the current origin.
+       * @param {Request} options.request The request to match.
+       * @param {Event} options.event The corresponding event.
+       * @return {Object} An object with `route` and `params` properties.
+       *     They are populated if a matching route was found or `undefined`
+       *     otherwise.
+       */
+
+
+      findMatchingRoute({
+        url,
+        sameOrigin,
+        request,
+        event
+      }) {
+        const routes = this._routes.get(request.method) || [];
+
+        for (const route of routes) {
+          let params; // route.match returns type any, not possible to change right now.
+          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
+
+          const matchResult = route.match({
+            url,
+            sameOrigin,
+            request,
+            event
+          });
+
+          if (matchResult) {
+            {
+              // Warn developers that using an async matchCallback is almost always
+              // not the right thing to do.
+              if (matchResult instanceof Promise) {
+                logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);
+              }
+            } // See https://github.com/GoogleChrome/workbox/issues/2079
+            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
+
+
+            params = matchResult;
+
+            if (Array.isArray(params) && params.length === 0) {
+              // Instead of passing an empty array in as params, use undefined.
+              params = undefined;
+            } else if (matchResult.constructor === Object && // eslint-disable-line
+            Object.keys(matchResult).length === 0) {
+              // Instead of passing an empty object in as params, use undefined.
+              params = undefined;
+            } else if (typeof matchResult === 'boolean') {
+              // For the boolean value true (rather than just something truth-y),
+              // don't set params.
+              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
+              params = undefined;
+            } // Return early if have a match.
+
+
+            return {
+              route,
+              params
+            };
+          }
+        } // If no match was found above, return and empty object.
+
+
+        return {};
+      }
+      /**
+       * Define a default `handler` that's called when no routes explicitly
+       * match the incoming request.
+       *
+       * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
+       *
+       * Without a default handler, unmatched requests will go against the
+       * network as if there were no service worker present.
+       *
+       * @param {workbox-routing~handlerCallback} handler A callback
+       * function that returns a Promise resulting in a Response.
+       * @param {string} [method='GET'] The HTTP method to associate with this
+       * default handler. Each method has its own default.
+       */
+
+
+      setDefaultHandler(handler, method = defaultMethod) {
+        this._defaultHandlerMap.set(method, normalizeHandler(handler));
+      }
+      /**
+       * If a Route throws an error while handling a request, this `handler`
+       * will be called and given a chance to provide a response.
+       *
+       * @param {workbox-routing~handlerCallback} handler A callback
+       * function that returns a Promise resulting in a Response.
+       */
+
+
+      setCatchHandler(handler) {
+        this._catchHandler = normalizeHandler(handler);
+      }
+      /**
+       * Registers a route with the router.
+       *
+       * @param {workbox-routing.Route} route The route to register.
+       */
+
+
+      registerRoute(route) {
+        {
+          finalAssertExports.isType(route, 'object', {
+            moduleName: 'workbox-routing',
+            className: 'Router',
+            funcName: 'registerRoute',
+            paramName: 'route'
+          });
+          finalAssertExports.hasMethod(route, 'match', {
+            moduleName: 'workbox-routing',
+            className: 'Router',
+            funcName: 'registerRoute',
+            paramName: 'route'
+          });
+          finalAssertExports.isType(route.handler, 'object', {
+            moduleName: 'workbox-routing',
+            className: 'Router',
+            funcName: 'registerRoute',
+            paramName: 'route'
+          });
+          finalAssertExports.hasMethod(route.handler, 'handle', {
+            moduleName: 'workbox-routing',
+            className: 'Router',
+            funcName: 'registerRoute',
+            paramName: 'route.handler'
+          });
+          finalAssertExports.isType(route.method, 'string', {
+            moduleName: 'workbox-routing',
+            className: 'Router',
+            funcName: 'registerRoute',
+            paramName: 'route.method'
+          });
+        }
+
+        if (!this._routes.has(route.method)) {
+          this._routes.set(route.method, []);
+        } // Give precedence to all of the earlier routes by adding this additional
+        // route to the end of the array.
+
+
+        this._routes.get(route.method).push(route);
+      }
+      /**
+       * Unregisters a route with the router.
+       *
+       * @param {workbox-routing.Route} route The route to unregister.
+       */
+
+
+      unregisterRoute(route) {
+        if (!this._routes.has(route.method)) {
+          throw new WorkboxError('unregister-route-but-not-found-with-method', {
+            method: route.method
+          });
+        }
+
+        const routeIndex = this._routes.get(route.method).indexOf(route);
+
+        if (routeIndex > -1) {
+          this._routes.get(route.method).splice(routeIndex, 1);
+        } else {
+          throw new WorkboxError('unregister-route-route-not-registered');
+        }
+      }
+
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    let defaultRouter;
+    /**
+     * Creates a new, singleton Router instance if one does not exist. If one
+     * does already exist, that instance is returned.
+     *
+     * @private
+     * @return {Router}
+     */
+
+    const getOrCreateDefaultRouter = () => {
+      if (!defaultRouter) {
+        defaultRouter = new Router(); // The helpers that use the default Router assume these listeners exist.
+
+        defaultRouter.addFetchListener();
+        defaultRouter.addCacheListener();
+      }
+
+      return defaultRouter;
+    };
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Easily register a RegExp, string, or function with a caching
+     * strategy to a singleton Router instance.
+     *
+     * This method will generate a Route for you if needed and
+     * call {@link workbox-routing.Router#registerRoute}.
+     *
+     * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture
+     * If the capture param is a `Route`, all other arguments will be ignored.
+     * @param {workbox-routing~handlerCallback} [handler] A callback
+     * function that returns a Promise resulting in a Response. This parameter
+     * is required if `capture` is not a `Route` object.
+     * @param {string} [method='GET'] The HTTP method to match the Route
+     * against.
+     * @return {workbox-routing.Route} The generated `Route`.
+     *
+     * @memberof workbox-routing
+     */
+
+    function registerRoute(capture, handler, method) {
+      let route;
+
+      if (typeof capture === 'string') {
+        const captureUrl = new URL(capture, location.href);
+
+        {
+          if (!(capture.startsWith('/') || capture.startsWith('http'))) {
+            throw new WorkboxError('invalid-string', {
+              moduleName: 'workbox-routing',
+              funcName: 'registerRoute',
+              paramName: 'capture'
+            });
+          } // We want to check if Express-style wildcards are in the pathname only.
+          // TODO: Remove this log message in v4.
+
+
+          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture; // See https://github.com/pillarjs/path-to-regexp#parameters
+
+          const wildcards = '[*:?+]';
+
+          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {
+            logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);
+          }
+        }
+
+        const matchCallback = ({
+          url
+        }) => {
+          {
+            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {
+              logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);
+            }
+          }
+
+          return url.href === captureUrl.href;
+        }; // If `capture` is a string then `handler` and `method` must be present.
+
+
+        route = new Route(matchCallback, handler, method);
+      } else if (capture instanceof RegExp) {
+        // If `capture` is a `RegExp` then `handler` and `method` must be present.
+        route = new RegExpRoute(capture, handler, method);
+      } else if (typeof capture === 'function') {
+        // If `capture` is a function then `handler` and `method` must be present.
+        route = new Route(capture, handler, method);
+      } else if (capture instanceof Route) {
+        route = capture;
+      } else {
+        throw new WorkboxError('unsupported-route-type', {
+          moduleName: 'workbox-routing',
+          funcName: 'registerRoute',
+          paramName: 'capture'
+        });
+      }
+
+      const defaultRouter = getOrCreateDefaultRouter();
+      defaultRouter.registerRoute(route);
+      return route;
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    const _cacheNameDetails = {
+      googleAnalytics: 'googleAnalytics',
+      precache: 'precache-v2',
+      prefix: 'workbox',
+      runtime: 'runtime',
+      suffix: typeof registration !== 'undefined' ? registration.scope : ''
+    };
+
+    const _createCacheName = cacheName => {
+      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');
+    };
+
+    const eachCacheNameDetail = fn => {
+      for (const key of Object.keys(_cacheNameDetails)) {
+        fn(key);
+      }
+    };
+
+    const cacheNames = {
+      updateDetails: details => {
+        eachCacheNameDetail(key => {
+          if (typeof details[key] === 'string') {
+            _cacheNameDetails[key] = details[key];
+          }
+        });
+      },
+      getGoogleAnalyticsName: userCacheName => {
+        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
+      },
+      getPrecacheName: userCacheName => {
+        return userCacheName || _createCacheName(_cacheNameDetails.precache);
+      },
+      getPrefix: () => {
+        return _cacheNameDetails.prefix;
+      },
+      getRuntimeName: userCacheName => {
+        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
+      },
+      getSuffix: () => {
+        return _cacheNameDetails.suffix;
+      }
+    };
+
+    /*
+      Copyright 2020 Google LLC
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * A utility method that makes it easier to use `event.waitUntil` with
+     * async functions and return the result.
+     *
+     * @param {ExtendableEvent} event
+     * @param {Function} asyncFn
+     * @return {Function}
+     * @private
+     */
+
+    function waitUntil(event, asyncFn) {
+      const returnPromise = asyncFn();
+      event.waitUntil(returnPromise);
+      return returnPromise;
+    }
+
+    try {
+      self['workbox:precaching:6.5.3'] && _();
+    } catch (e) {}
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+
+    const REVISION_SEARCH_PARAM = '__WB_REVISION__';
+    /**
+     * Converts a manifest entry into a versioned URL suitable for precaching.
+     *
+     * @param {Object|string} entry
+     * @return {string} A URL with versioning info.
+     *
+     * @private
+     * @memberof workbox-precaching
+     */
+
+    function createCacheKey(entry) {
+      if (!entry) {
+        throw new WorkboxError('add-to-cache-list-unexpected-type', {
+          entry
+        });
+      } // If a precache manifest entry is a string, it's assumed to be a versioned
+      // URL, like '/app.abcd1234.js'. Return as-is.
+
+
+      if (typeof entry === 'string') {
+        const urlObject = new URL(entry, location.href);
+        return {
+          cacheKey: urlObject.href,
+          url: urlObject.href
+        };
+      }
+
+      const {
+        revision,
+        url
+      } = entry;
+
+      if (!url) {
+        throw new WorkboxError('add-to-cache-list-unexpected-type', {
+          entry
+        });
+      } // If there's just a URL and no revision, then it's also assumed to be a
+      // versioned URL.
+
+
+      if (!revision) {
+        const urlObject = new URL(url, location.href);
+        return {
+          cacheKey: urlObject.href,
+          url: urlObject.href
+        };
+      } // Otherwise, construct a properly versioned URL using the custom Workbox
+      // search parameter along with the revision info.
+
+
+      const cacheKeyURL = new URL(url, location.href);
+      const originalURL = new URL(url, location.href);
+      cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
+      return {
+        cacheKey: cacheKeyURL.href,
+        url: originalURL.href
+      };
+    }
+
+    /*
+      Copyright 2020 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * A plugin, designed to be used with PrecacheController, to determine the
+     * of assets that were updated (or not updated) during the install event.
+     *
+     * @private
+     */
+
+    class PrecacheInstallReportPlugin {
+      constructor() {
+        this.updatedURLs = [];
+        this.notUpdatedURLs = [];
+
+        this.handlerWillStart = async ({
+          request,
+          state
+        }) => {
+          // TODO: `state` should never be undefined...
+          if (state) {
+            state.originalRequest = request;
+          }
+        };
+
+        this.cachedResponseWillBeUsed = async ({
+          event,
+          state,
+          cachedResponse
+        }) => {
+          if (event.type === 'install') {
+            if (state && state.originalRequest && state.originalRequest instanceof Request) {
+              // TODO: `state` should never be undefined...
+              const url = state.originalRequest.url;
+
+              if (cachedResponse) {
+                this.notUpdatedURLs.push(url);
+              } else {
+                this.updatedURLs.push(url);
+              }
+            }
+          }
+
+          return cachedResponse;
+        };
+      }
+
+    }
+
+    /*
+      Copyright 2020 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * A plugin, designed to be used with PrecacheController, to translate URLs into
+     * the corresponding cache key, based on the current revision info.
+     *
+     * @private
+     */
+
+    class PrecacheCacheKeyPlugin {
+      constructor({
+        precacheController
+      }) {
+        this.cacheKeyWillBeUsed = async ({
+          request,
+          params
+        }) => {
+          // Params is type any, can't change right now.
+
+          /* eslint-disable */
+          const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);
+          /* eslint-enable */
+
+
+          return cacheKey ? new Request(cacheKey, {
+            headers: request.headers
+          }) : request;
+        };
+
+        this._precacheController = precacheController;
+      }
+
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * @param {string} groupTitle
+     * @param {Array<string>} deletedURLs
+     *
+     * @private
+     */
+
+    const logGroup = (groupTitle, deletedURLs) => {
+      logger.groupCollapsed(groupTitle);
+
+      for (const url of deletedURLs) {
+        logger.log(url);
+      }
+
+      logger.groupEnd();
+    };
+    /**
+     * @param {Array<string>} deletedURLs
+     *
+     * @private
+     * @memberof workbox-precaching
+     */
+
+
+    function printCleanupDetails(deletedURLs) {
+      const deletionCount = deletedURLs.length;
+
+      if (deletionCount > 0) {
+        logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);
+        logGroup('Deleted Cache Requests', deletedURLs);
+        logger.groupEnd();
+      }
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * @param {string} groupTitle
+     * @param {Array<string>} urls
+     *
+     * @private
+     */
+
+    function _nestedGroup(groupTitle, urls) {
+      if (urls.length === 0) {
+        return;
+      }
+
+      logger.groupCollapsed(groupTitle);
+
+      for (const url of urls) {
+        logger.log(url);
+      }
+
+      logger.groupEnd();
+    }
+    /**
+     * @param {Array<string>} urlsToPrecache
+     * @param {Array<string>} urlsAlreadyPrecached
+     *
+     * @private
+     * @memberof workbox-precaching
+     */
+
+
+    function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {
+      const precachedCount = urlsToPrecache.length;
+      const alreadyPrecachedCount = urlsAlreadyPrecached.length;
+
+      if (precachedCount || alreadyPrecachedCount) {
+        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;
+
+        if (alreadyPrecachedCount > 0) {
+          message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;
+        }
+
+        logger.groupCollapsed(message);
+
+        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);
+
+        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);
+
+        logger.groupEnd();
+      }
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    let supportStatus;
+    /**
+     * A utility function that determines whether the current browser supports
+     * constructing a new `Response` from a `response.body` stream.
+     *
+     * @return {boolean} `true`, if the current browser can successfully
+     *     construct a `Response` from a `response.body` stream, `false` otherwise.
+     *
+     * @private
+     */
+
+    function canConstructResponseFromBodyStream() {
+      if (supportStatus === undefined) {
+        const testResponse = new Response('');
+
+        if ('body' in testResponse) {
+          try {
+            new Response(testResponse.body);
+            supportStatus = true;
+          } catch (error) {
+            supportStatus = false;
+          }
+        }
+
+        supportStatus = false;
+      }
+
+      return supportStatus;
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Allows developers to copy a response and modify its `headers`, `status`,
+     * or `statusText` values (the values settable via a
+     * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}
+     * object in the constructor).
+     * To modify these values, pass a function as the second argument. That
+     * function will be invoked with a single object with the response properties
+     * `{headers, status, statusText}`. The return value of this function will
+     * be used as the `ResponseInit` for the new `Response`. To change the values
+     * either modify the passed parameter(s) and return it, or return a totally
+     * new object.
+     *
+     * This method is intentionally limited to same-origin responses, regardless of
+     * whether CORS was used or not.
+     *
+     * @param {Response} response
+     * @param {Function} modifier
+     * @memberof workbox-core
+     */
+
+    async function copyResponse(response, modifier) {
+      let origin = null; // If response.url isn't set, assume it's cross-origin and keep origin null.
+
+      if (response.url) {
+        const responseURL = new URL(response.url);
+        origin = responseURL.origin;
+      }
+
+      if (origin !== self.location.origin) {
+        throw new WorkboxError('cross-origin-copy-response', {
+          origin
+        });
+      }
+
+      const clonedResponse = response.clone(); // Create a fresh `ResponseInit` object by cloning the headers.
+
+      const responseInit = {
+        headers: new Headers(clonedResponse.headers),
+        status: clonedResponse.status,
+        statusText: clonedResponse.statusText
+      }; // Apply any user modifications.
+
+      const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit; // Create the new response from the body stream and `ResponseInit`
+      // modifications. Note: not all browsers support the Response.body stream,
+      // so fall back to reading the entire body into memory as a blob.
+
+      const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();
+      return new Response(body, modifiedResponseInit);
+    }
+
+    /*
+      Copyright 2020 Google LLC
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+
+    function stripParams(fullURL, ignoreParams) {
+      const strippedURL = new URL(fullURL);
+
+      for (const param of ignoreParams) {
+        strippedURL.searchParams.delete(param);
+      }
+
+      return strippedURL.href;
+    }
+    /**
+     * Matches an item in the cache, ignoring specific URL params. This is similar
+     * to the `ignoreSearch` option, but it allows you to ignore just specific
+     * params (while continuing to match on the others).
+     *
+     * @private
+     * @param {Cache} cache
+     * @param {Request} request
+     * @param {Object} matchOptions
+     * @param {Array<string>} ignoreParams
+     * @return {Promise<Response|undefined>}
+     */
+
+
+    async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
+      const strippedRequestURL = stripParams(request.url, ignoreParams); // If the request doesn't include any ignored params, match as normal.
+
+      if (request.url === strippedRequestURL) {
+        return cache.match(request, matchOptions);
+      } // Otherwise, match by comparing keys
+
+
+      const keysOptions = Object.assign(Object.assign({}, matchOptions), {
+        ignoreSearch: true
+      });
+      const cacheKeys = await cache.keys(request, keysOptions);
+
+      for (const cacheKey of cacheKeys) {
+        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
+
+        if (strippedRequestURL === strippedCacheKeyURL) {
+          return cache.match(cacheKey, matchOptions);
+        }
+      }
+
+      return;
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * The Deferred class composes Promises in a way that allows for them to be
+     * resolved or rejected from outside the constructor. In most cases promises
+     * should be used directly, but Deferreds can be necessary when the logic to
+     * resolve a promise must be separate.
+     *
+     * @private
+     */
+
+    class Deferred {
+      /**
+       * Creates a promise and exposes its resolve and reject functions as methods.
+       */
+      constructor() {
+        this.promise = new Promise((resolve, reject) => {
+          this.resolve = resolve;
+          this.reject = reject;
+        });
+      }
+
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    // Can't change Function type right now.
+    // eslint-disable-next-line @typescript-eslint/ban-types
+
+    const quotaErrorCallbacks = new Set();
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Runs all of the callback functions, one at a time sequentially, in the order
+     * in which they were registered.
+     *
+     * @memberof workbox-core
+     * @private
+     */
+
+    async function executeQuotaErrorCallbacks() {
+      {
+        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);
+      }
+
+      for (const callback of quotaErrorCallbacks) {
+        await callback();
+
+        {
+          logger.log(callback, 'is complete.');
+        }
+      }
+
+      {
+        logger.log('Finished running callbacks.');
+      }
+    }
+
+    /*
+      Copyright 2019 Google LLC
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Returns a promise that resolves and the passed number of milliseconds.
+     * This utility is an async/await-friendly version of `setTimeout`.
+     *
+     * @param {number} ms
+     * @return {Promise}
+     * @private
+     */
+
+    function timeout(ms) {
+      return new Promise(resolve => setTimeout(resolve, ms));
+    }
+
+    try {
+      self['workbox:strategies:6.5.3'] && _();
+    } catch (e) {}
+
+    /*
+      Copyright 2020 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+
+    function toRequest(input) {
+      return typeof input === 'string' ? new Request(input) : input;
+    }
+    /**
+     * A class created every time a Strategy instance instance calls
+     * {@link workbox-strategies.Strategy~handle} or
+     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and
+     * cache actions around plugin callbacks and keeps track of when the strategy
+     * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
+     *
+     * @memberof workbox-strategies
+     */
+
+
+    class StrategyHandler {
+      /**
+       * Creates a new instance associated with the passed strategy and event
+       * that's handling the request.
+       *
+       * The constructor also initializes the state that will be passed to each of
+       * the plugins handling this request.
+       *
+       * @param {workbox-strategies.Strategy} strategy
+       * @param {Object} options
+       * @param {Request|string} options.request A request to run this strategy for.
+       * @param {ExtendableEvent} options.event The event associated with the
+       *     request.
+       * @param {URL} [options.url]
+       * @param {*} [options.params] The return value from the
+       *     {@link workbox-routing~matchCallback} (if applicable).
+       */
+      constructor(strategy, options) {
+        this._cacheKeys = {};
+        /**
+         * The request the strategy is performing (passed to the strategy's
+         * `handle()` or `handleAll()` method).
+         * @name request
+         * @instance
+         * @type {Request}
+         * @memberof workbox-strategies.StrategyHandler
+         */
+
+        /**
+         * The event associated with this request.
+         * @name event
+         * @instance
+         * @type {ExtendableEvent}
+         * @memberof workbox-strategies.StrategyHandler
+         */
+
+        /**
+         * A `URL` instance of `request.url` (if passed to the strategy's
+         * `handle()` or `handleAll()` method).
+         * Note: the `url` param will be present if the strategy was invoked
+         * from a workbox `Route` object.
+         * @name url
+         * @instance
+         * @type {URL|undefined}
+         * @memberof workbox-strategies.StrategyHandler
+         */
+
+        /**
+         * A `param` value (if passed to the strategy's
+         * `handle()` or `handleAll()` method).
+         * Note: the `param` param will be present if the strategy was invoked
+         * from a workbox `Route` object and the
+         * {@link workbox-routing~matchCallback} returned
+         * a truthy value (it will be that value).
+         * @name params
+         * @instance
+         * @type {*|undefined}
+         * @memberof workbox-strategies.StrategyHandler
+         */
+
+        {
+          finalAssertExports.isInstance(options.event, ExtendableEvent, {
+            moduleName: 'workbox-strategies',
+            className: 'StrategyHandler',
+            funcName: 'constructor',
+            paramName: 'options.event'
+          });
+        }
+
+        Object.assign(this, options);
+        this.event = options.event;
+        this._strategy = strategy;
+        this._handlerDeferred = new Deferred();
+        this._extendLifetimePromises = []; // Copy the plugins list (since it's mutable on the strategy),
+        // so any mutations don't affect this handler instance.
+
+        this._plugins = [...strategy.plugins];
+        this._pluginStateMap = new Map();
+
+        for (const plugin of this._plugins) {
+          this._pluginStateMap.set(plugin, {});
+        }
+
+        this.event.waitUntil(this._handlerDeferred.promise);
+      }
+      /**
+       * Fetches a given request (and invokes any applicable plugin callback
+       * methods) using the `fetchOptions` (for non-navigation requests) and
+       * `plugins` defined on the `Strategy` object.
+       *
+       * The following plugin lifecycle methods are invoked when using this method:
+       * - `requestWillFetch()`
+       * - `fetchDidSucceed()`
+       * - `fetchDidFail()`
+       *
+       * @param {Request|string} input The URL or request to fetch.
+       * @return {Promise<Response>}
+       */
+
+
+      async fetch(input) {
+        const {
+          event
+        } = this;
+        let request = toRequest(input);
+
+        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {
+          const possiblePreloadResponse = await event.preloadResponse;
+
+          if (possiblePreloadResponse) {
+            {
+              logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);
+            }
+
+            return possiblePreloadResponse;
+          }
+        } // If there is a fetchDidFail plugin, we need to save a clone of the
+        // original request before it's either modified by a requestWillFetch
+        // plugin or before the original request's body is consumed via fetch().
+
+
+        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;
+
+        try {
+          for (const cb of this.iterateCallbacks('requestWillFetch')) {
+            request = await cb({
+              request: request.clone(),
+              event
+            });
+          }
+        } catch (err) {
+          if (err instanceof Error) {
+            throw new WorkboxError('plugin-error-request-will-fetch', {
+              thrownErrorMessage: err.message
+            });
+          }
+        } // The request can be altered by plugins with `requestWillFetch` making
+        // the original request (most likely from a `fetch` event) different
+        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
+
+
+        const pluginFilteredRequest = request.clone();
+
+        try {
+          let fetchResponse; // See https://github.com/GoogleChrome/workbox/issues/1796
+
+          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);
+
+          if ("development" !== 'production') {
+            logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);
+          }
+
+          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
+            fetchResponse = await callback({
+              event,
+              request: pluginFilteredRequest,
+              response: fetchResponse
+            });
+          }
+
+          return fetchResponse;
+        } catch (error) {
+          {
+            logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);
+          } // `originalRequest` will only exist if a `fetchDidFail` callback
+          // is being used (see above).
+
+
+          if (originalRequest) {
+            await this.runCallbacks('fetchDidFail', {
+              error: error,
+              event,
+              originalRequest: originalRequest.clone(),
+              request: pluginFilteredRequest.clone()
+            });
+          }
+
+          throw error;
+        }
+      }
+      /**
+       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
+       * the response generated by `this.fetch()`.
+       *
+       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
+       * so you do not have to manually call `waitUntil()` on the event.
+       *
+       * @param {Request|string} input The request or URL to fetch and cache.
+       * @return {Promise<Response>}
+       */
+
+
+      async fetchAndCachePut(input) {
+        const response = await this.fetch(input);
+        const responseClone = response.clone();
+        void this.waitUntil(this.cachePut(input, responseClone));
+        return response;
+      }
+      /**
+       * Matches a request from the cache (and invokes any applicable plugin
+       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
+       * defined on the strategy object.
+       *
+       * The following plugin lifecycle methods are invoked when using this method:
+       * - cacheKeyWillByUsed()
+       * - cachedResponseWillByUsed()
+       *
+       * @param {Request|string} key The Request or URL to use as the cache key.
+       * @return {Promise<Response|undefined>} A matching response, if found.
+       */
+
+
+      async cacheMatch(key) {
+        const request = toRequest(key);
+        let cachedResponse;
+        const {
+          cacheName,
+          matchOptions
+        } = this._strategy;
+        const effectiveRequest = await this.getCacheKey(request, 'read');
+        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {
+          cacheName
+        });
+        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
+
+        {
+          if (cachedResponse) {
+            logger.debug(`Found a cached response in '${cacheName}'.`);
+          } else {
+            logger.debug(`No cached response found in '${cacheName}'.`);
+          }
+        }
+
+        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
+          cachedResponse = (await callback({
+            cacheName,
+            matchOptions,
+            cachedResponse,
+            request: effectiveRequest,
+            event: this.event
+          })) || undefined;
+        }
+
+        return cachedResponse;
+      }
+      /**
+       * Puts a request/response pair in the cache (and invokes any applicable
+       * plugin callback methods) using the `cacheName` and `plugins` defined on
+       * the strategy object.
+       *
+       * The following plugin lifecycle methods are invoked when using this method:
+       * - cacheKeyWillByUsed()
+       * - cacheWillUpdate()
+       * - cacheDidUpdate()
+       *
+       * @param {Request|string} key The request or URL to use as the cache key.
+       * @param {Response} response The response to cache.
+       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
+       * not be cached, and `true` otherwise.
+       */
+
+
+      async cachePut(key, response) {
+        const request = toRequest(key); // Run in the next task to avoid blocking other cache reads.
+        // https://github.com/w3c/ServiceWorker/issues/1397
+
+        await timeout(0);
+        const effectiveRequest = await this.getCacheKey(request, 'write');
+
+        {
+          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
+            throw new WorkboxError('attempt-to-cache-non-get-request', {
+              url: getFriendlyURL(effectiveRequest.url),
+              method: effectiveRequest.method
+            });
+          } // See https://github.com/GoogleChrome/workbox/issues/2818
+
+
+          const vary = response.headers.get('Vary');
+
+          if (vary) {
+            logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);
+          }
+        }
+
+        if (!response) {
+          {
+            logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);
+          }
+
+          throw new WorkboxError('cache-put-with-no-response', {
+            url: getFriendlyURL(effectiveRequest.url)
+          });
+        }
+
+        const responseToCache = await this._ensureResponseSafeToCache(response);
+
+        if (!responseToCache) {
+          {
+            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);
+          }
+
+          return false;
+        }
+
+        const {
+          cacheName,
+          matchOptions
+        } = this._strategy;
+        const cache = await self.caches.open(cacheName);
+        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
+        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams( // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
+        // feature. Consider into ways to only add this behavior if using
+        // precaching.
+        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;
+
+        {
+          logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);
+        }
+
+        try {
+          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);
+        } catch (error) {
+          if (error instanceof Error) {
+            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
+            if (error.name === 'QuotaExceededError') {
+              await executeQuotaErrorCallbacks();
+            }
+
+            throw error;
+          }
+        }
+
+        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
+          await callback({
+            cacheName,
+            oldResponse,
+            newResponse: responseToCache.clone(),
+            request: effectiveRequest,
+            event: this.event
+          });
+        }
+
+        return true;
+      }
+      /**
+       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
+       * executes any of those callbacks found in sequence. The final `Request`
+       * object returned by the last plugin is treated as the cache key for cache
+       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
+       * been registered, the passed request is returned unmodified
+       *
+       * @param {Request} request
+       * @param {string} mode
+       * @return {Promise<Request>}
+       */
+
+
+      async getCacheKey(request, mode) {
+        const key = `${request.url} | ${mode}`;
+
+        if (!this._cacheKeys[key]) {
+          let effectiveRequest = request;
+
+          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
+            effectiveRequest = toRequest(await callback({
+              mode,
+              request: effectiveRequest,
+              event: this.event,
+              // params has a type any can't change right now.
+              params: this.params // eslint-disable-line
+
+            }));
+          }
+
+          this._cacheKeys[key] = effectiveRequest;
+        }
+
+        return this._cacheKeys[key];
+      }
+      /**
+       * Returns true if the strategy has at least one plugin with the given
+       * callback.
+       *
+       * @param {string} name The name of the callback to check for.
+       * @return {boolean}
+       */
+
+
+      hasCallback(name) {
+        for (const plugin of this._strategy.plugins) {
+          if (name in plugin) {
+            return true;
+          }
+        }
+
+        return false;
+      }
+      /**
+       * Runs all plugin callbacks matching the given name, in order, passing the
+       * given param object (merged ith the current plugin state) as the only
+       * argument.
+       *
+       * Note: since this method runs all plugins, it's not suitable for cases
+       * where the return value of a callback needs to be applied prior to calling
+       * the next callback. See
+       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
+       * below for how to handle that case.
+       *
+       * @param {string} name The name of the callback to run within each plugin.
+       * @param {Object} param The object to pass as the first (and only) param
+       *     when executing each callback. This object will be merged with the
+       *     current plugin state prior to callback execution.
+       */
+
+
+      async runCallbacks(name, param) {
+        for (const callback of this.iterateCallbacks(name)) {
+          // TODO(philipwalton): not sure why `any` is needed. It seems like
+          // this should work with `as WorkboxPluginCallbackParam[C]`.
+          await callback(param);
+        }
+      }
+      /**
+       * Accepts a callback and returns an iterable of matching plugin callbacks,
+       * where each callback is wrapped with the current handler state (i.e. when
+       * you call each callback, whatever object parameter you pass it will
+       * be merged with the plugin's current state).
+       *
+       * @param {string} name The name fo the callback to run
+       * @return {Array<Function>}
+       */
+
+
+      *iterateCallbacks(name) {
+        for (const plugin of this._strategy.plugins) {
+          if (typeof plugin[name] === 'function') {
+            const state = this._pluginStateMap.get(plugin);
+
+            const statefulCallback = param => {
+              const statefulParam = Object.assign(Object.assign({}, param), {
+                state
+              }); // TODO(philipwalton): not sure why `any` is needed. It seems like
+              // this should work with `as WorkboxPluginCallbackParam[C]`.
+
+              return plugin[name](statefulParam);
+            };
+
+            yield statefulCallback;
+          }
+        }
+      }
+      /**
+       * Adds a promise to the
+       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
+       * of the event event associated with the request being handled (usually a
+       * `FetchEvent`).
+       *
+       * Note: you can await
+       * {@link workbox-strategies.StrategyHandler~doneWaiting}
+       * to know when all added promises have settled.
+       *
+       * @param {Promise} promise A promise to add to the extend lifetime promises
+       *     of the event that triggered the request.
+       */
+
+
+      waitUntil(promise) {
+        this._extendLifetimePromises.push(promise);
+
+        return promise;
+      }
+      /**
+       * Returns a promise that resolves once all promises passed to
+       * {@link workbox-strategies.StrategyHandler~waitUntil}
+       * have settled.
+       *
+       * Note: any work done after `doneWaiting()` settles should be manually
+       * passed to an event's `waitUntil()` method (not this handler's
+       * `waitUntil()` method), otherwise the service worker thread my be killed
+       * prior to your work completing.
+       */
+
+
+      async doneWaiting() {
+        let promise;
+
+        while (promise = this._extendLifetimePromises.shift()) {
+          await promise;
+        }
+      }
+      /**
+       * Stops running the strategy and immediately resolves any pending
+       * `waitUntil()` promises.
+       */
+
+
+      destroy() {
+        this._handlerDeferred.resolve(null);
+      }
+      /**
+       * This method will call cacheWillUpdate on the available plugins (or use
+       * status === 200) to determine if the Response is safe and valid to cache.
+       *
+       * @param {Request} options.request
+       * @param {Response} options.response
+       * @return {Promise<Response|undefined>}
+       *
+       * @private
+       */
+
+
+      async _ensureResponseSafeToCache(response) {
+        let responseToCache = response;
+        let pluginsUsed = false;
+
+        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
+          responseToCache = (await callback({
+            request: this.request,
+            response: responseToCache,
+            event: this.event
+          })) || undefined;
+          pluginsUsed = true;
+
+          if (!responseToCache) {
+            break;
+          }
+        }
+
+        if (!pluginsUsed) {
+          if (responseToCache && responseToCache.status !== 200) {
+            responseToCache = undefined;
+          }
+
+          {
+            if (responseToCache) {
+              if (responseToCache.status !== 200) {
+                if (responseToCache.status === 0) {
+                  logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);
+                } else {
+                  logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);
+                }
+              }
+            }
+          }
+        }
+
+        return responseToCache;
+      }
+
+    }
+
+    /*
+      Copyright 2020 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * An abstract base class that all other strategy classes must extend from:
+     *
+     * @memberof workbox-strategies
+     */
+
+    class Strategy {
+      /**
+       * Creates a new instance of the strategy and sets all documented option
+       * properties as public instance properties.
+       *
+       * Note: if a custom strategy class extends the base Strategy class and does
+       * not need more than these properties, it does not need to define its own
+       * constructor.
+       *
+       * @param {Object} [options]
+       * @param {string} [options.cacheName] Cache name to store and retrieve
+       * requests. Defaults to the cache names provided by
+       * {@link workbox-core.cacheNames}.
+       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
+       * to use in conjunction with this caching strategy.
+       * @param {Object} [options.fetchOptions] Values passed along to the
+       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
+       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
+       * `fetch()` requests made by this strategy.
+       * @param {Object} [options.matchOptions] The
+       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
+       * for any `cache.match()` or `cache.put()` calls made by this strategy.
+       */
+      constructor(options = {}) {
+        /**
+         * Cache name to store and retrieve
+         * requests. Defaults to the cache names provided by
+         * {@link workbox-core.cacheNames}.
+         *
+         * @type {string}
+         */
+        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
+        /**
+         * The list
+         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
+         * used by this strategy.
+         *
+         * @type {Array<Object>}
+         */
+
+        this.plugins = options.plugins || [];
+        /**
+         * Values passed along to the
+         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
+         * of all fetch() requests made by this strategy.
+         *
+         * @type {Object}
+         */
+
+        this.fetchOptions = options.fetchOptions;
+        /**
+         * The
+         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
+         * for any `cache.match()` or `cache.put()` calls made by this strategy.
+         *
+         * @type {Object}
+         */
+
+        this.matchOptions = options.matchOptions;
+      }
+      /**
+       * Perform a request strategy and returns a `Promise` that will resolve with
+       * a `Response`, invoking all relevant plugin callbacks.
+       *
+       * When a strategy instance is registered with a Workbox
+       * {@link workbox-routing.Route}, this method is automatically
+       * called when the route matches.
+       *
+       * Alternatively, this method can be used in a standalone `FetchEvent`
+       * listener by passing it to `event.respondWith()`.
+       *
+       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
+       *     properties listed below.
+       * @param {Request|string} options.request A request to run this strategy for.
+       * @param {ExtendableEvent} options.event The event associated with the
+       *     request.
+       * @param {URL} [options.url]
+       * @param {*} [options.params]
+       */
+
+
+      handle(options) {
+        const [responseDone] = this.handleAll(options);
+        return responseDone;
+      }
+      /**
+       * Similar to {@link workbox-strategies.Strategy~handle}, but
+       * instead of just returning a `Promise` that resolves to a `Response` it
+       * it will return an tuple of `[response, done]` promises, where the former
+       * (`response`) is equivalent to what `handle()` returns, and the latter is a
+       * Promise that will resolve once any promises that were added to
+       * `event.waitUntil()` as part of performing the strategy have completed.
+       *
+       * You can await the `done` promise to ensure any extra work performed by
+       * the strategy (usually caching responses) completes successfully.
+       *
+       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
+       *     properties listed below.
+       * @param {Request|string} options.request A request to run this strategy for.
+       * @param {ExtendableEvent} options.event The event associated with the
+       *     request.
+       * @param {URL} [options.url]
+       * @param {*} [options.params]
+       * @return {Array<Promise>} A tuple of [response, done]
+       *     promises that can be used to determine when the response resolves as
+       *     well as when the handler has completed all its work.
+       */
+
+
+      handleAll(options) {
+        // Allow for flexible options to be passed.
+        if (options instanceof FetchEvent) {
+          options = {
+            event: options,
+            request: options.request
+          };
+        }
+
+        const event = options.event;
+        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;
+        const params = 'params' in options ? options.params : undefined;
+        const handler = new StrategyHandler(this, {
+          event,
+          request,
+          params
+        });
+
+        const responseDone = this._getResponse(handler, request, event);
+
+        const handlerDone = this._awaitComplete(responseDone, handler, request, event); // Return an array of promises, suitable for use with Promise.all().
+
+
+        return [responseDone, handlerDone];
+      }
+
+      async _getResponse(handler, request, event) {
+        await handler.runCallbacks('handlerWillStart', {
+          event,
+          request
+        });
+        let response = undefined;
+
+        try {
+          response = await this._handle(request, handler); // The "official" Strategy subclasses all throw this error automatically,
+          // but in case a third-party Strategy doesn't, ensure that we have a
+          // consistent failure when there's no response or an error response.
+
+          if (!response || response.type === 'error') {
+            throw new WorkboxError('no-response', {
+              url: request.url
+            });
+          }
+        } catch (error) {
+          if (error instanceof Error) {
+            for (const callback of handler.iterateCallbacks('handlerDidError')) {
+              response = await callback({
+                error,
+                event,
+                request
+              });
+
+              if (response) {
+                break;
+              }
+            }
+          }
+
+          if (!response) {
+            throw error;
+          } else {
+            logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);
+          }
+        }
+
+        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
+          response = await callback({
+            event,
+            request,
+            response
+          });
+        }
+
+        return response;
+      }
+
+      async _awaitComplete(responseDone, handler, request, event) {
+        let response;
+        let error;
+
+        try {
+          response = await responseDone;
+        } catch (error) {// Ignore errors, as response errors should be caught via the `response`
+          // promise above. The `done` promise will only throw for errors in
+          // promises passed to `handler.waitUntil()`.
+        }
+
+        try {
+          await handler.runCallbacks('handlerDidRespond', {
+            event,
+            request,
+            response
+          });
+          await handler.doneWaiting();
+        } catch (waitUntilError) {
+          if (waitUntilError instanceof Error) {
+            error = waitUntilError;
+          }
+        }
+
+        await handler.runCallbacks('handlerDidComplete', {
+          event,
+          request,
+          response,
+          error: error
+        });
+        handler.destroy();
+
+        if (error) {
+          throw error;
+        }
+      }
+
+    }
+    /**
+     * Classes extending the `Strategy` based class should implement this method,
+     * and leverage the {@link workbox-strategies.StrategyHandler}
+     * arg to perform all fetching and cache logic, which will ensure all relevant
+     * cache, cache options, fetch options and plugins are used (per the current
+     * strategy instance).
+     *
+     * @name _handle
+     * @instance
+     * @abstract
+     * @function
+     * @param {Request} request
+     * @param {workbox-strategies.StrategyHandler} handler
+     * @return {Promise<Response>}
+     *
+     * @memberof workbox-strategies.Strategy
+     */
+
+    /*
+      Copyright 2020 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * A {@link workbox-strategies.Strategy} implementation
+     * specifically designed to work with
+     * {@link workbox-precaching.PrecacheController}
+     * to both cache and fetch precached assets.
+     *
+     * Note: an instance of this class is created automatically when creating a
+     * `PrecacheController`; it's generally not necessary to create this yourself.
+     *
+     * @extends workbox-strategies.Strategy
+     * @memberof workbox-precaching
+     */
+
+    class PrecacheStrategy extends Strategy {
+      /**
+       *
+       * @param {Object} [options]
+       * @param {string} [options.cacheName] Cache name to store and retrieve
+       * requests. Defaults to the cache names provided by
+       * {@link workbox-core.cacheNames}.
+       * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}
+       * to use in conjunction with this caching strategy.
+       * @param {Object} [options.fetchOptions] Values passed along to the
+       * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}
+       * of all fetch() requests made by this strategy.
+       * @param {Object} [options.matchOptions] The
+       * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}
+       * for any `cache.match()` or `cache.put()` calls made by this strategy.
+       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
+       * get the response from the network if there's a precache miss.
+       */
+      constructor(options = {}) {
+        options.cacheName = cacheNames.getPrecacheName(options.cacheName);
+        super(options);
+        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true; // Redirected responses cannot be used to satisfy a navigation request, so
+        // any redirected response must be "copied" rather than cloned, so the new
+        // response doesn't contain the `redirected` flag. See:
+        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
+
+        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);
+      }
+      /**
+       * @private
+       * @param {Request|string} request A request to run this strategy for.
+       * @param {workbox-strategies.StrategyHandler} handler The event that
+       *     triggered the request.
+       * @return {Promise<Response>}
+       */
+
+
+      async _handle(request, handler) {
+        const response = await handler.cacheMatch(request);
+
+        if (response) {
+          return response;
+        } // If this is an `install` event for an entry that isn't already cached,
+        // then populate the cache.
+
+
+        if (handler.event && handler.event.type === 'install') {
+          return await this._handleInstall(request, handler);
+        } // Getting here means something went wrong. An entry that should have been
+        // precached wasn't found in the cache.
+
+
+        return await this._handleFetch(request, handler);
+      }
+
+      async _handleFetch(request, handler) {
+        let response;
+        const params = handler.params || {}; // Fall back to the network if we're configured to do so.
+
+        if (this._fallbackToNetwork) {
+          {
+            logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);
+          }
+
+          const integrityInManifest = params.integrity;
+          const integrityInRequest = request.integrity;
+          const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest; // Do not add integrity if the original request is no-cors
+          // See https://github.com/GoogleChrome/workbox/issues/3096
+
+          response = await handler.fetch(new Request(request, {
+            integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined
+          })); // It's only "safe" to repair the cache if we're using SRI to guarantee
+          // that the response matches the precache manifest's expectations,
+          // and there's either a) no integrity property in the incoming request
+          // or b) there is an integrity, and it matches the precache manifest.
+          // See https://github.com/GoogleChrome/workbox/issues/2858
+          // Also if the original request users no-cors we don't use integrity.
+          // See https://github.com/GoogleChrome/workbox/issues/3096
+
+          if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {
+            this._useDefaultCacheabilityPluginIfNeeded();
+
+            const wasCached = await handler.cachePut(request, response.clone());
+
+            {
+              if (wasCached) {
+                logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to "repair" the precache.`);
+              }
+            }
+          }
+        } else {
+          // This shouldn't normally happen, but there are edge cases:
+          // https://github.com/GoogleChrome/workbox/issues/1441
+          throw new WorkboxError('missing-precache-entry', {
+            cacheName: this.cacheName,
+            url: request.url
+          });
+        }
+
+        {
+          const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read')); // Workbox is going to handle the route.
+          // print the routing details to the console.
+
+          logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));
+          logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);
+          logger.groupCollapsed(`View request details here.`);
+          logger.log(request);
+          logger.groupEnd();
+          logger.groupCollapsed(`View response details here.`);
+          logger.log(response);
+          logger.groupEnd();
+          logger.groupEnd();
+        }
+
+        return response;
+      }
+
+      async _handleInstall(request, handler) {
+        this._useDefaultCacheabilityPluginIfNeeded();
+
+        const response = await handler.fetch(request); // Make sure we defer cachePut() until after we know the response
+        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737
+
+        const wasCached = await handler.cachePut(request, response.clone());
+
+        if (!wasCached) {
+          // Throwing here will lead to the `install` handler failing, which
+          // we want to do if *any* of the responses aren't safe to cache.
+          throw new WorkboxError('bad-precaching-response', {
+            url: request.url,
+            status: response.status
+          });
+        }
+
+        return response;
+      }
+      /**
+       * This method is complex, as there a number of things to account for:
+       *
+       * The `plugins` array can be set at construction, and/or it might be added to
+       * to at any time before the strategy is used.
+       *
+       * At the time the strategy is used (i.e. during an `install` event), there
+       * needs to be at least one plugin that implements `cacheWillUpdate` in the
+       * array, other than `copyRedirectedCacheableResponsesPlugin`.
+       *
+       * - If this method is called and there are no suitable `cacheWillUpdate`
+       * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.
+       *
+       * - If this method is called and there is exactly one `cacheWillUpdate`, then
+       * we don't have to do anything (this might be a previously added
+       * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).
+       *
+       * - If this method is called and there is more than one `cacheWillUpdate`,
+       * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,
+       * we need to remove it. (This situation is unlikely, but it could happen if
+       * the strategy is used multiple times, the first without a `cacheWillUpdate`,
+       * and then later on after manually adding a custom `cacheWillUpdate`.)
+       *
+       * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.
+       *
+       * @private
+       */
+
+
+      _useDefaultCacheabilityPluginIfNeeded() {
+        let defaultPluginIndex = null;
+        let cacheWillUpdatePluginCount = 0;
+
+        for (const [index, plugin] of this.plugins.entries()) {
+          // Ignore the copy redirected plugin when determining what to do.
+          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {
+            continue;
+          } // Save the default plugin's index, in case it needs to be removed.
+
+
+          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {
+            defaultPluginIndex = index;
+          }
+
+          if (plugin.cacheWillUpdate) {
+            cacheWillUpdatePluginCount++;
+          }
+        }
+
+        if (cacheWillUpdatePluginCount === 0) {
+          this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);
+        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {
+          // Only remove the default plugin; multiple custom plugins are allowed.
+          this.plugins.splice(defaultPluginIndex, 1);
+        } // Nothing needs to be done if cacheWillUpdatePluginCount is 1
+
+      }
+
+    }
+
+    PrecacheStrategy.defaultPrecacheCacheabilityPlugin = {
+      async cacheWillUpdate({
+        response
+      }) {
+        if (!response || response.status >= 400) {
+          return null;
+        }
+
+        return response;
+      }
+
+    };
+    PrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {
+      async cacheWillUpdate({
+        response
+      }) {
+        return response.redirected ? await copyResponse(response) : response;
+      }
+
+    };
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Performs efficient precaching of assets.
+     *
+     * @memberof workbox-precaching
+     */
+
+    class PrecacheController {
+      /**
+       * Create a new PrecacheController.
+       *
+       * @param {Object} [options]
+       * @param {string} [options.cacheName] The cache to use for precaching.
+       * @param {string} [options.plugins] Plugins to use when precaching as well
+       * as responding to fetch events for precached assets.
+       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
+       * get the response from the network if there's a precache miss.
+       */
+      constructor({
+        cacheName,
+        plugins = [],
+        fallbackToNetwork = true
+      } = {}) {
+        this._urlsToCacheKeys = new Map();
+        this._urlsToCacheModes = new Map();
+        this._cacheKeysToIntegrities = new Map();
+        this._strategy = new PrecacheStrategy({
+          cacheName: cacheNames.getPrecacheName(cacheName),
+          plugins: [...plugins, new PrecacheCacheKeyPlugin({
+            precacheController: this
+          })],
+          fallbackToNetwork
+        }); // Bind the install and activate methods to the instance.
+
+        this.install = this.install.bind(this);
+        this.activate = this.activate.bind(this);
+      }
+      /**
+       * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and
+       * used to cache assets and respond to fetch events.
+       */
+
+
+      get strategy() {
+        return this._strategy;
+      }
+      /**
+       * Adds items to the precache list, removing any duplicates and
+       * stores the files in the
+       * {@link workbox-core.cacheNames|"precache cache"} when the service
+       * worker installs.
+       *
+       * This method can be called multiple times.
+       *
+       * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
+       */
+
+
+      precache(entries) {
+        this.addToCacheList(entries);
+
+        if (!this._installAndActiveListenersAdded) {
+          self.addEventListener('install', this.install);
+          self.addEventListener('activate', this.activate);
+          this._installAndActiveListenersAdded = true;
+        }
+      }
+      /**
+       * This method will add items to the precache list, removing duplicates
+       * and ensuring the information is valid.
+       *
+       * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
+       *     Array of entries to precache.
+       */
+
+
+      addToCacheList(entries) {
+        {
+          finalAssertExports.isArray(entries, {
+            moduleName: 'workbox-precaching',
+            className: 'PrecacheController',
+            funcName: 'addToCacheList',
+            paramName: 'entries'
+          });
+        }
+
+        const urlsToWarnAbout = [];
+
+        for (const entry of entries) {
+          // See https://github.com/GoogleChrome/workbox/issues/2259
+          if (typeof entry === 'string') {
+            urlsToWarnAbout.push(entry);
+          } else if (entry && entry.revision === undefined) {
+            urlsToWarnAbout.push(entry.url);
+          }
+
+          const {
+            cacheKey,
+            url
+          } = createCacheKey(entry);
+          const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';
+
+          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {
+            throw new WorkboxError('add-to-cache-list-conflicting-entries', {
+              firstEntry: this._urlsToCacheKeys.get(url),
+              secondEntry: cacheKey
+            });
+          }
+
+          if (typeof entry !== 'string' && entry.integrity) {
+            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
+              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {
+                url
+              });
+            }
+
+            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
+          }
+
+          this._urlsToCacheKeys.set(url, cacheKey);
+
+          this._urlsToCacheModes.set(url, cacheMode);
+
+          if (urlsToWarnAbout.length > 0) {
+            const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;
+
+            {
+              logger.warn(warningMessage);
+            }
+          }
+        }
+      }
+      /**
+       * Precaches new and updated assets. Call this method from the service worker
+       * install event.
+       *
+       * Note: this method calls `event.waitUntil()` for you, so you do not need
+       * to call it yourself in your event handlers.
+       *
+       * @param {ExtendableEvent} event
+       * @return {Promise<workbox-precaching.InstallResult>}
+       */
+
+
+      install(event) {
+        // waitUntil returns Promise<any>
+        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
+        return waitUntil(event, async () => {
+          const installReportPlugin = new PrecacheInstallReportPlugin();
+          this.strategy.plugins.push(installReportPlugin); // Cache entries one at a time.
+          // See https://github.com/GoogleChrome/workbox/issues/2528
+
+          for (const [url, cacheKey] of this._urlsToCacheKeys) {
+            const integrity = this._cacheKeysToIntegrities.get(cacheKey);
+
+            const cacheMode = this._urlsToCacheModes.get(url);
+
+            const request = new Request(url, {
+              integrity,
+              cache: cacheMode,
+              credentials: 'same-origin'
+            });
+            await Promise.all(this.strategy.handleAll({
+              params: {
+                cacheKey
+              },
+              request,
+              event
+            }));
+          }
+
+          const {
+            updatedURLs,
+            notUpdatedURLs
+          } = installReportPlugin;
+
+          {
+            printInstallDetails(updatedURLs, notUpdatedURLs);
+          }
+
+          return {
+            updatedURLs,
+            notUpdatedURLs
+          };
+        });
+      }
+      /**
+       * Deletes assets that are no longer present in the current precache manifest.
+       * Call this method from the service worker activate event.
+       *
+       * Note: this method calls `event.waitUntil()` for you, so you do not need
+       * to call it yourself in your event handlers.
+       *
+       * @param {ExtendableEvent} event
+       * @return {Promise<workbox-precaching.CleanupResult>}
+       */
+
+
+      activate(event) {
+        // waitUntil returns Promise<any>
+        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
+        return waitUntil(event, async () => {
+          const cache = await self.caches.open(this.strategy.cacheName);
+          const currentlyCachedRequests = await cache.keys();
+          const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
+          const deletedURLs = [];
+
+          for (const request of currentlyCachedRequests) {
+            if (!expectedCacheKeys.has(request.url)) {
+              await cache.delete(request);
+              deletedURLs.push(request.url);
+            }
+          }
+
+          {
+            printCleanupDetails(deletedURLs);
+          }
+
+          return {
+            deletedURLs
+          };
+        });
+      }
+      /**
+       * Returns a mapping of a precached URL to the corresponding cache key, taking
+       * into account the revision information for the URL.
+       *
+       * @return {Map<string, string>} A URL to cache key mapping.
+       */
+
+
+      getURLsToCacheKeys() {
+        return this._urlsToCacheKeys;
+      }
+      /**
+       * Returns a list of all the URLs that have been precached by the current
+       * service worker.
+       *
+       * @return {Array<string>} The precached URLs.
+       */
+
+
+      getCachedURLs() {
+        return [...this._urlsToCacheKeys.keys()];
+      }
+      /**
+       * Returns the cache key used for storing a given URL. If that URL is
+       * unversioned, like `/index.html', then the cache key will be the original
+       * URL with a search parameter appended to it.
+       *
+       * @param {string} url A URL whose cache key you want to look up.
+       * @return {string} The versioned URL that corresponds to a cache key
+       * for the original URL, or undefined if that URL isn't precached.
+       */
+
+
+      getCacheKeyForURL(url) {
+        const urlObject = new URL(url, location.href);
+        return this._urlsToCacheKeys.get(urlObject.href);
+      }
+      /**
+       * @param {string} url A cache key whose SRI you want to look up.
+       * @return {string} The subresource integrity associated with the cache key,
+       * or undefined if it's not set.
+       */
+
+
+      getIntegrityForCacheKey(cacheKey) {
+        return this._cacheKeysToIntegrities.get(cacheKey);
+      }
+      /**
+       * This acts as a drop-in replacement for
+       * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
+       * with the following differences:
+       *
+       * - It knows what the name of the precache is, and only checks in that cache.
+       * - It allows you to pass in an "original" URL without versioning parameters,
+       * and it will automatically look up the correct cache key for the currently
+       * active revision of that URL.
+       *
+       * E.g., `matchPrecache('index.html')` will find the correct precached
+       * response for the currently active service worker, even if the actual cache
+       * key is `'/index.html?__WB_REVISION__=1234abcd'`.
+       *
+       * @param {string|Request} request The key (without revisioning parameters)
+       * to look up in the precache.
+       * @return {Promise<Response|undefined>}
+       */
+
+
+      async matchPrecache(request) {
+        const url = request instanceof Request ? request.url : request;
+        const cacheKey = this.getCacheKeyForURL(url);
+
+        if (cacheKey) {
+          const cache = await self.caches.open(this.strategy.cacheName);
+          return cache.match(cacheKey);
+        }
+
+        return undefined;
+      }
+      /**
+       * Returns a function that looks up `url` in the precache (taking into
+       * account revision information), and returns the corresponding `Response`.
+       *
+       * @param {string} url The precached URL which will be used to lookup the
+       * `Response`.
+       * @return {workbox-routing~handlerCallback}
+       */
+
+
+      createHandlerBoundToURL(url) {
+        const cacheKey = this.getCacheKeyForURL(url);
+
+        if (!cacheKey) {
+          throw new WorkboxError('non-precached-url', {
+            url
+          });
+        }
+
+        return options => {
+          options.request = new Request(url);
+          options.params = Object.assign({
+            cacheKey
+          }, options.params);
+          return this.strategy.handle(options);
+        };
+      }
+
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    let precacheController;
+    /**
+     * @return {PrecacheController}
+     * @private
+     */
+
+    const getOrCreatePrecacheController = () => {
+      if (!precacheController) {
+        precacheController = new PrecacheController();
+      }
+
+      return precacheController;
+    };
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Removes any URL search parameters that should be ignored.
+     *
+     * @param {URL} urlObject The original URL.
+     * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against
+     * each search parameter name. Matches mean that the search parameter should be
+     * ignored.
+     * @return {URL} The URL with any ignored search parameters removed.
+     *
+     * @private
+     * @memberof workbox-precaching
+     */
+
+    function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
+      // Convert the iterable into an array at the start of the loop to make sure
+      // deletion doesn't mess up iteration.
+      for (const paramName of [...urlObject.searchParams.keys()]) {
+        if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {
+          urlObject.searchParams.delete(paramName);
+        }
+      }
+
+      return urlObject;
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Generator function that yields possible variations on the original URL to
+     * check, one at a time.
+     *
+     * @param {string} url
+     * @param {Object} options
+     *
+     * @private
+     * @memberof workbox-precaching
+     */
+
+    function* generateURLVariations(url, {
+      ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],
+      directoryIndex = 'index.html',
+      cleanURLs = true,
+      urlManipulation
+    } = {}) {
+      const urlObject = new URL(url, location.href);
+      urlObject.hash = '';
+      yield urlObject.href;
+      const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
+      yield urlWithoutIgnoredParams.href;
+
+      if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
+        const directoryURL = new URL(urlWithoutIgnoredParams.href);
+        directoryURL.pathname += directoryIndex;
+        yield directoryURL.href;
+      }
+
+      if (cleanURLs) {
+        const cleanURL = new URL(urlWithoutIgnoredParams.href);
+        cleanURL.pathname += '.html';
+        yield cleanURL.href;
+      }
+
+      if (urlManipulation) {
+        const additionalURLs = urlManipulation({
+          url: urlObject
+        });
+
+        for (const urlToAttempt of additionalURLs) {
+          yield urlToAttempt.href;
+        }
+      }
+    }
+
+    /*
+      Copyright 2020 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * A subclass of {@link workbox-routing.Route} that takes a
+     * {@link workbox-precaching.PrecacheController}
+     * instance and uses it to match incoming requests and handle fetching
+     * responses from the precache.
+     *
+     * @memberof workbox-precaching
+     * @extends workbox-routing.Route
+     */
+
+    class PrecacheRoute extends Route {
+      /**
+       * @param {PrecacheController} precacheController A `PrecacheController`
+       * instance used to both match requests and respond to fetch events.
+       * @param {Object} [options] Options to control how requests are matched
+       * against the list of precached URLs.
+       * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
+       * check cache entries for a URLs ending with '/' to see if there is a hit when
+       * appending the `directoryIndex` value.
+       * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
+       * array of regex's to remove search params when looking for a cache match.
+       * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
+       * check the cache for the URL with a `.html` added to the end of the end.
+       * @param {workbox-precaching~urlManipulation} [options.urlManipulation]
+       * This is a function that should take a URL and return an array of
+       * alternative URLs that should be checked for precache matches.
+       */
+      constructor(precacheController, options) {
+        const match = ({
+          request
+        }) => {
+          const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
+
+          for (const possibleURL of generateURLVariations(request.url, options)) {
+            const cacheKey = urlsToCacheKeys.get(possibleURL);
+
+            if (cacheKey) {
+              const integrity = precacheController.getIntegrityForCacheKey(cacheKey);
+              return {
+                cacheKey,
+                integrity
+              };
+            }
+          }
+
+          {
+            logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));
+          }
+
+          return;
+        };
+
+        super(match, precacheController.strategy);
+      }
+
+    }
+
+    /*
+      Copyright 2019 Google LLC
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Add a `fetch` listener to the service worker that will
+     * respond to
+     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}
+     * with precached assets.
+     *
+     * Requests for assets that aren't precached, the `FetchEvent` will not be
+     * responded to, allowing the event to fall through to other `fetch` event
+     * listeners.
+     *
+     * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}
+     * options.
+     *
+     * @memberof workbox-precaching
+     */
+
+    function addRoute(options) {
+      const precacheController = getOrCreatePrecacheController();
+      const precacheRoute = new PrecacheRoute(precacheController, options);
+      registerRoute(precacheRoute);
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Adds items to the precache list, removing any duplicates and
+     * stores the files in the
+     * {@link workbox-core.cacheNames|"precache cache"} when the service
+     * worker installs.
+     *
+     * This method can be called multiple times.
+     *
+     * Please note: This method **will not** serve any of the cached files for you.
+     * It only precaches files. To respond to a network request you call
+     * {@link workbox-precaching.addRoute}.
+     *
+     * If you have a single array of files to precache, you can just call
+     * {@link workbox-precaching.precacheAndRoute}.
+     *
+     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
+     *
+     * @memberof workbox-precaching
+     */
+
+    function precache(entries) {
+      const precacheController = getOrCreatePrecacheController();
+      precacheController.precache(entries);
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * This method will add entries to the precache list and add a route to
+     * respond to fetch events.
+     *
+     * This is a convenience method that will call
+     * {@link workbox-precaching.precache} and
+     * {@link workbox-precaching.addRoute} in a single call.
+     *
+     * @param {Array<Object|string>} entries Array of entries to precache.
+     * @param {Object} [options] See the
+     * {@link workbox-precaching.PrecacheRoute} options.
+     *
+     * @memberof workbox-precaching
+     */
+
+    function precacheAndRoute(entries, options) {
+      precache(entries);
+      addRoute(options);
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    const SUBSTRING_TO_FIND = '-precache-';
+    /**
+     * Cleans up incompatible precaches that were created by older versions of
+     * Workbox, by a service worker registered under the current scope.
+     *
+     * This is meant to be called as part of the `activate` event.
+     *
+     * This should be safe to use as long as you don't include `substringToFind`
+     * (defaulting to `-precache-`) in your non-precache cache names.
+     *
+     * @param {string} currentPrecacheName The cache name currently in use for
+     * precaching. This cache won't be deleted.
+     * @param {string} [substringToFind='-precache-'] Cache names which include this
+     * substring will be deleted (excluding `currentPrecacheName`).
+     * @return {Array<string>} A list of all the cache names that were deleted.
+     *
+     * @private
+     * @memberof workbox-precaching
+     */
+
+    const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {
+      const cacheNames = await self.caches.keys();
+      const cacheNamesToDelete = cacheNames.filter(cacheName => {
+        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;
+      });
+      await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));
+      return cacheNamesToDelete;
+    };
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Adds an `activate` event listener which will clean up incompatible
+     * precaches that were created by older versions of Workbox.
+     *
+     * @memberof workbox-precaching
+     */
+
+    function cleanupOutdatedCaches() {
+      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
+      self.addEventListener('activate', event => {
+        const cacheName = cacheNames.getPrecacheName();
+        event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {
+          {
+            if (cachesDeleted.length > 0) {
+              logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);
+            }
+          }
+        }));
+      });
+    }
+
+    /*
+      Copyright 2018 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * NavigationRoute makes it easy to create a
+     * {@link workbox-routing.Route} that matches for browser
+     * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.
+     *
+     * It will only match incoming Requests whose
+     * {@link https://fetch.spec.whatwg.org/#concept-request-mode|mode}
+     * is set to `navigate`.
+     *
+     * You can optionally only apply this route to a subset of navigation requests
+     * by using one or both of the `denylist` and `allowlist` parameters.
+     *
+     * @memberof workbox-routing
+     * @extends workbox-routing.Route
+     */
+
+    class NavigationRoute extends Route {
+      /**
+       * If both `denylist` and `allowlist` are provided, the `denylist` will
+       * take precedence and the request will not match this route.
+       *
+       * The regular expressions in `allowlist` and `denylist`
+       * are matched against the concatenated
+       * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}
+       * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}
+       * portions of the requested URL.
+       *
+       * *Note*: These RegExps may be evaluated against every destination URL during
+       * a navigation. Avoid using
+       * [complex RegExps](https://github.com/GoogleChrome/workbox/issues/3077),
+       * or else your users may see delays when navigating your site.
+       *
+       * @param {workbox-routing~handlerCallback} handler A callback
+       * function that returns a Promise resulting in a Response.
+       * @param {Object} options
+       * @param {Array<RegExp>} [options.denylist] If any of these patterns match,
+       * the route will not handle the request (even if a allowlist RegExp matches).
+       * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns
+       * match the URL's pathname and search parameter, the route will handle the
+       * request (assuming the denylist doesn't match).
+       */
+      constructor(handler, {
+        allowlist = [/./],
+        denylist = []
+      } = {}) {
+        {
+          finalAssertExports.isArrayOfClass(allowlist, RegExp, {
+            moduleName: 'workbox-routing',
+            className: 'NavigationRoute',
+            funcName: 'constructor',
+            paramName: 'options.allowlist'
+          });
+          finalAssertExports.isArrayOfClass(denylist, RegExp, {
+            moduleName: 'workbox-routing',
+            className: 'NavigationRoute',
+            funcName: 'constructor',
+            paramName: 'options.denylist'
+          });
+        }
+
+        super(options => this._match(options), handler);
+        this._allowlist = allowlist;
+        this._denylist = denylist;
+      }
+      /**
+       * Routes match handler.
+       *
+       * @param {Object} options
+       * @param {URL} options.url
+       * @param {Request} options.request
+       * @return {boolean}
+       *
+       * @private
+       */
+
+
+      _match({
+        url,
+        request
+      }) {
+        if (request && request.mode !== 'navigate') {
+          return false;
+        }
+
+        const pathnameAndSearch = url.pathname + url.search;
+
+        for (const regExp of this._denylist) {
+          if (regExp.test(pathnameAndSearch)) {
+            {
+              logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL matches this denylist pattern: ` + `${regExp.toString()}`);
+            }
+
+            return false;
+          }
+        }
+
+        if (this._allowlist.some(regExp => regExp.test(pathnameAndSearch))) {
+          {
+            logger.debug(`The navigation route ${pathnameAndSearch} ` + `is being used.`);
+          }
+
+          return true;
+        }
+
+        {
+          logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL being navigated to doesn't ` + `match the allowlist.`);
+        }
+
+        return false;
+      }
+
+    }
+
+    /*
+      Copyright 2019 Google LLC
+
+      Use of this source code is governed by an MIT-style
+      license that can be found in the LICENSE file or at
+      https://opensource.org/licenses/MIT.
+    */
+    /**
+     * Helper function that calls
+     * {@link PrecacheController#createHandlerBoundToURL} on the default
+     * {@link PrecacheController} instance.
+     *
+     * If you are creating your own {@link PrecacheController}, then call the
+     * {@link PrecacheController#createHandlerBoundToURL} on that instance,
+     * instead of using this function.
+     *
+     * @param {string} url The precached URL which will be used to lookup the
+     * `Response`.
+     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the
+     * response from the network if there's a precache miss.
+     * @return {workbox-routing~handlerCallback}
+     *
+     * @memberof workbox-precaching
+     */
+
+    function createHandlerBoundToURL(url) {
+      const precacheController = getOrCreatePrecacheController();
+      return precacheController.createHandlerBoundToURL(url);
+    }
+
+    exports.NavigationRoute = NavigationRoute;
+    exports.cleanupOutdatedCaches = cleanupOutdatedCaches;
+    exports.clientsClaim = clientsClaim;
+    exports.createHandlerBoundToURL = createHandlerBoundToURL;
+    exports.precacheAndRoute = precacheAndRoute;
+    exports.registerRoute = registerRoute;
+
+}));
diff --git a/index.html b/index.html
index d8e0d2a..21c710a 100644
--- a/index.html
+++ b/index.html
@@ -12,5 +12,6 @@
   <body>
     <div id="app"></div>
     <script type="module" src="/src/main.tsx"></script>
+    <!-- <script type="module" src="/src/sw.js"></script> -->
   </body>
 </html>
diff --git a/package-lock.json b/package-lock.json
index 7ec7c81..cd6bcc7 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -8,9 +8,9 @@
       "name": "otw-scoring",
       "version": "0.0.0",
       "dependencies": {
-        "@chakra-ui/react": "^1.8.6",
-        "@emotion/react": "^11.9.0",
-        "@emotion/styled": "^11.8.1",
+        "@chakra-ui/react": "^1.8.8",
+        "@emotion/react": "^11.10.4",
+        "@emotion/styled": "^11.10.4",
         "@faker-js/faker": "^7.3.0",
         "@js-temporal/polyfill": "^0.4.0",
         "@mui/icons-material": "^5.8.4",
@@ -18,9 +18,10 @@
         "file-dialog": "^0.0.8",
         "firebase": "^9.6.4",
         "formik": "^2.2.9",
-        "framer-motion": "^6.2.8",
+        "framer-motion": "^6.5.1",
         "papaparse": "^5.3.1",
         "preact": "^10.10.1",
+        "preact-async-route": "^2.2.1",
         "preact-render-to-string": "^5.1.4",
         "preact-router": "^3.2.1",
         "react-firebase-hooks": "^5.0.2"
@@ -44,8 +45,9 @@
         "preact-cli": "^3.0.0",
         "preact-material-components": "^1.6.1",
         "sirv-cli": "^1.0.0-next.3",
-        "typescript": "^4.6.4",
-        "vite": "^3.0.7"
+        "typescript": "^4.5.2",
+        "vite": "^3.0.7",
+        "vite-plugin-pwa": "^0.12.6"
       }
     },
     "node_modules/@ampproject/remapping": {
@@ -21969,6 +21971,11 @@
         "url": "https://opencollective.com/preact"
       }
     },
+    "node_modules/preact-async-route": {
+      "version": "2.2.1",
+      "resolved": "https://registry.npmjs.org/preact-async-route/-/preact-async-route-2.2.1.tgz",
+      "integrity": "sha512-8bg1007akXs3YDmzYT4McaTe6ji2FIzcc0/NTlu+vjJaKPNQ8lNG/HQ6LP+FoIxQ4m/KH5vvJCHJN5ADp2iNGA=="
+    },
     "node_modules/preact-cli": {
       "version": "3.4.1",
       "resolved": "https://registry.npmjs.org/preact-cli/-/preact-cli-3.4.1.tgz",
@@ -26152,9 +26159,9 @@
       }
     },
     "node_modules/typescript": {
-      "version": "4.8.2",
-      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.8.2.tgz",
-      "integrity": "sha512-C0I1UsrrDHo2fYI5oaCGbSejwX4ch+9Y5jTQELvovfmFkK3HHSZJB8MSJcWLmCUBzQBchCrZ9rMRV6GuNrvGtw==",
+      "version": "4.5.2",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.5.2.tgz",
+      "integrity": "sha512-5BlMof9H1yGt0P8/WF+wPNw6GfctgGjXp5hkblpyT+8rkASSmkUKMXrxR0Xg8ThVCi/JnHQiKXeBaEwCeQwMFw==",
       "dev": true,
       "bin": {
         "tsc": "bin/tsc",
@@ -26876,6 +26883,40 @@
         }
       }
     },
+    "node_modules/vite-plugin-pwa": {
+      "version": "0.12.6",
+      "resolved": "https://registry.npmjs.org/vite-plugin-pwa/-/vite-plugin-pwa-0.12.6.tgz",
+      "integrity": "sha512-qRxx1zUlwKq2QD20nDZVL449wV+dflRVeDMLa2k4LZiHfWRfHWwmdhnDZOlMEgni0Zss1DkhyTmuzLYuO6aO3A==",
+      "dev": true,
+      "dependencies": {
+        "debug": "^4.3.4",
+        "fast-glob": "^3.2.11",
+        "pretty-bytes": "^6.0.0",
+        "rollup": "^2.75.7",
+        "workbox-build": "^6.5.3",
+        "workbox-window": "^6.5.3"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/antfu"
+      },
+      "peerDependencies": {
+        "vite": "^2.0.0 || ^3.0.0-0",
+        "workbox-build": "^6.4.0",
+        "workbox-window": "^6.4.0"
+      }
+    },
+    "node_modules/vite-plugin-pwa/node_modules/pretty-bytes": {
+      "version": "6.0.0",
+      "resolved": "https://registry.npmjs.org/pretty-bytes/-/pretty-bytes-6.0.0.tgz",
+      "integrity": "sha512-6UqkYefdogmzqAZWzJ7laYeJnaXDy2/J+ZqiiMtS7t7OfpXWTlaeGMwX8U6EFvPV/YWWEKRkS8hKS4k60WHTOg==",
+      "dev": true,
+      "engines": {
+        "node": "^14.13.1 || >=16.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
+    },
     "node_modules/vm-browserify": {
       "version": "1.1.2",
       "resolved": "https://registry.npmjs.org/vm-browserify/-/vm-browserify-1.1.2.tgz",
@@ -45598,6 +45639,11 @@
       "resolved": "https://registry.npmjs.org/preact/-/preact-10.10.6.tgz",
       "integrity": "sha512-w0mCL5vICUAZrh1DuHEdOWBjxdO62lvcO++jbzr8UhhYcTbFkpegLH9XX+7MadjTl/y0feoqwQ/zAnzkc/EGog=="
     },
+    "preact-async-route": {
+      "version": "2.2.1",
+      "resolved": "https://registry.npmjs.org/preact-async-route/-/preact-async-route-2.2.1.tgz",
+      "integrity": "sha512-8bg1007akXs3YDmzYT4McaTe6ji2FIzcc0/NTlu+vjJaKPNQ8lNG/HQ6LP+FoIxQ4m/KH5vvJCHJN5ADp2iNGA=="
+    },
     "preact-cli": {
       "version": "3.4.1",
       "resolved": "https://registry.npmjs.org/preact-cli/-/preact-cli-3.4.1.tgz",
@@ -48919,9 +48965,9 @@
       }
     },
     "typescript": {
-      "version": "4.8.2",
-      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.8.2.tgz",
-      "integrity": "sha512-C0I1UsrrDHo2fYI5oaCGbSejwX4ch+9Y5jTQELvovfmFkK3HHSZJB8MSJcWLmCUBzQBchCrZ9rMRV6GuNrvGtw==",
+      "version": "4.5.2",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.5.2.tgz",
+      "integrity": "sha512-5BlMof9H1yGt0P8/WF+wPNw6GfctgGjXp5hkblpyT+8rkASSmkUKMXrxR0Xg8ThVCi/JnHQiKXeBaEwCeQwMFw==",
       "dev": true
     },
     "uglify-js": {
@@ -49439,6 +49485,28 @@
         "rollup": ">=2.75.6 <2.77.0 || ~2.77.0"
       }
     },
+    "vite-plugin-pwa": {
+      "version": "0.12.6",
+      "resolved": "https://registry.npmjs.org/vite-plugin-pwa/-/vite-plugin-pwa-0.12.6.tgz",
+      "integrity": "sha512-qRxx1zUlwKq2QD20nDZVL449wV+dflRVeDMLa2k4LZiHfWRfHWwmdhnDZOlMEgni0Zss1DkhyTmuzLYuO6aO3A==",
+      "dev": true,
+      "requires": {
+        "debug": "^4.3.4",
+        "fast-glob": "^3.2.11",
+        "pretty-bytes": "^6.0.0",
+        "rollup": "^2.75.7",
+        "workbox-build": "^6.5.3",
+        "workbox-window": "^6.5.3"
+      },
+      "dependencies": {
+        "pretty-bytes": {
+          "version": "6.0.0",
+          "resolved": "https://registry.npmjs.org/pretty-bytes/-/pretty-bytes-6.0.0.tgz",
+          "integrity": "sha512-6UqkYefdogmzqAZWzJ7laYeJnaXDy2/J+ZqiiMtS7t7OfpXWTlaeGMwX8U6EFvPV/YWWEKRkS8hKS4k60WHTOg==",
+          "dev": true
+        }
+      }
+    },
     "vm-browserify": {
       "version": "1.1.2",
       "resolved": "https://registry.npmjs.org/vm-browserify/-/vm-browserify-1.1.2.tgz",
diff --git a/package.json b/package.json
index 7a977ef..4628d99 100644
--- a/package.json
+++ b/package.json
@@ -10,10 +10,9 @@
     "em-start": " firebase emulators:start"
   },
   "dependencies": {
-    "preact": "^10.10.1",
-    "@chakra-ui/react": "^1.8.6",
-    "@emotion/react": "^11.9.0",
-    "@emotion/styled": "^11.8.1",
+    "@chakra-ui/react": "^1.8.8",
+    "@emotion/react": "^11.10.4",
+    "@emotion/styled": "^11.10.4",
     "@faker-js/faker": "^7.3.0",
     "@js-temporal/polyfill": "^0.4.0",
     "@mui/icons-material": "^5.8.4",
@@ -21,17 +20,16 @@
     "file-dialog": "^0.0.8",
     "firebase": "^9.6.4",
     "formik": "^2.2.9",
-    "framer-motion": "^6.2.8",
+    "framer-motion": "^6.5.1",
     "papaparse": "^5.3.1",
+    "preact": "^10.10.1",
+    "preact-async-route": "^2.2.1",
     "preact-render-to-string": "^5.1.4",
     "preact-router": "^3.2.1",
     "react-firebase-hooks": "^5.0.2"
-
   },
   "devDependencies": {
     "@preact/preset-vite": "^2.3.0",
-    "typescript": "^4.6.4",
-    "vite": "^3.0.7",
     "@types/enzyme": "^3.10.5",
     "@types/jest": "^26.0.8",
     "@types/papaparse": "^5.3.2",
@@ -48,6 +46,9 @@
     "jest-preset-preact": "^4.0.2",
     "preact-cli": "^3.0.0",
     "preact-material-components": "^1.6.1",
-    "sirv-cli": "^1.0.0-next.3"
+    "sirv-cli": "^1.0.0-next.3",
+    "typescript": "^4.5.2",
+    "vite": "^3.0.7",
+    "vite-plugin-pwa": "^0.12.6"
   }
-}
\ No newline at end of file
+}
diff --git a/src/.babelrc b/src/______.babelrc
similarity index 100%
rename from src/.babelrc
rename to src/______.babelrc
diff --git a/src/app.css b/src/app.css
deleted file mode 100644
index 088ed3a..0000000
--- a/src/app.css
+++ /dev/null
@@ -1,25 +0,0 @@
-#app {
-  max-width: 1280px;
-  margin: 0 auto;
-  padding: 2rem;
-  text-align: center;
-}
-
-.logo {
-  height: 6em;
-  padding: 1.5em;
-}
-.logo:hover {
-  filter: drop-shadow(0 0 2em #646cffaa);
-}
-.logo.preact:hover {
-  filter: drop-shadow(0 0 2em #673ab8aa);
-}
-
-.card {
-  padding: 2em;
-}
-
-.read-the-docs {
-  color: #888;
-}
diff --git a/src/app.tsx b/src/app.tsx
index 2803a5d..b44d8bc 100644
--- a/src/app.tsx
+++ b/src/app.tsx
@@ -1,16 +1,31 @@
-import { Box, ChakraProvider, extendTheme } from "@chakra-ui/react";
+import {
+  Box,
+  ChakraProvider,
+  extendTheme,
+  withDefaultColorScheme,
+} from "@chakra-ui/react";
 import { h } from "preact";
 import { useState } from "preact/hooks";
 import { useAuthState } from "react-firebase-hooks/auth";
 import SidebarWithHeader from "./components/header/SidebarWithHeader";
 import Routing from "./components/page/Routing";
-import { theme } from "./components/page/theme";
+import { components, colors, fonts } from "./components/page/theme";
 import { auth } from "./util/firebase-config";
 
 export function App() {
   const [user] = useAuthState(auth);
-
+  const annoyingMessage = document.querySelector(".firebase-emulator-warning");
+  annoyingMessage?.removeAttribute("style");
   const [headerTitle, setHeaderTitle] = useState("Blw Me");
+  const [userColorScheme, setUserColorScheme] = useState("blue");
+  const theme = extendTheme(
+    withDefaultColorScheme({ colorScheme: userColorScheme }),
+    {
+      components,
+      colors,
+      fonts,
+    }
+  );
 
   return (
     <div id="preact_root">
diff --git a/src/components/animations/FadeSlide.tsx b/src/components/animations/FadeSlide.tsx
index 5208809..9e19b2e 100644
--- a/src/components/animations/FadeSlide.tsx
+++ b/src/components/animations/FadeSlide.tsx
@@ -1,7 +1,7 @@
 import { FunctionalComponent, h } from "preact";
 import { AnimatePresence, motion } from "framer-motion";
 
-export const FadeInSlideLeft: FunctionalComponent = ({ children }) => {
+export function FadeInSlideLeft({ children }) {
   return (
     <motion.div
       transition={{ ease: "easeOut", duration: 0.25 }}
@@ -18,9 +18,9 @@ export const FadeInSlideLeft: FunctionalComponent = ({ children }) => {
       {children}
     </motion.div>
   );
-};
+}
 
-export const SiteListAnimation: FunctionalComponent = ({ children }) => {
+export function SiteListAnimation({ children }) {
   return (
     <AnimatePresence>
       <motion.div
@@ -46,9 +46,9 @@ export const SiteListAnimation: FunctionalComponent = ({ children }) => {
       </motion.div>
     </AnimatePresence>
   );
-};
+}
 
-export const FadeInSlideRight: FunctionalComponent = ({ children }) => {
+export function FadeInSlideRight({ children }) {
   return (
     <motion.div
       transition={{ ease: "easeOut", duration: 0.25 }}
@@ -65,9 +65,9 @@ export const FadeInSlideRight: FunctionalComponent = ({ children }) => {
       {children}
     </motion.div>
   );
-};
+}
 
-export const FadeIn: FunctionalComponent = ({ children }) => {
+export function FadeIn({ children }) {
   return (
     <motion.div
       transition={{ ease: "easeOut", duration: 0.25 }}
@@ -84,9 +84,9 @@ export const FadeIn: FunctionalComponent = ({ children }) => {
       {children}
     </motion.div>
   );
-};
+}
 
-export const FadeOut: FunctionalComponent = ({ children }) => {
+export function FadeOut({ children }) {
   return (
     <motion.div
       transition={{ ease: "easeOut", duration: 0.25 }}
@@ -101,4 +101,4 @@ export const FadeOut: FunctionalComponent = ({ children }) => {
       {children}
     </motion.div>
   );
-};
+}
diff --git a/src/components/generic/ButtonGroup.tsx b/src/components/generic/ButtonGroup.tsx
index 911c9b9..3f96d8b 100644
--- a/src/components/generic/ButtonGroup.tsx
+++ b/src/components/generic/ButtonGroup.tsx
@@ -38,8 +38,8 @@ export default function BtnGrp({
               isActive={selectedButton === label ? true : false}
               _active={{
                 boxShadow: "none",
-                background: "blue.100",
-                color: "blue.600",
+                // background: "blue.100",
+                // color: "blue.600",
               }}
             >
               {label}
diff --git a/src/components/generic/ColorToggleMode.tsx b/src/components/generic/ColorToggleMode.tsx
index 388092a..ab95a77 100644
--- a/src/components/generic/ColorToggleMode.tsx
+++ b/src/components/generic/ColorToggleMode.tsx
@@ -2,15 +2,16 @@ import { h } from "preact";
 import { Button, ButtonProps, useColorMode } from "@chakra-ui/react";
 import MdDarkModeIcon from "@mui/icons-material/DarkMode";
 import MdLightModeIcon from "@mui/icons-material/LightMode";
+import SecBtn from "./SecBtn";
 
-export default function ColorModeToggle(props: ButtonProps) {
+export default function ColorModeToggle(props) {
   const { colorMode, toggleColorMode } = useColorMode();
   return (
     <Button
-      aria-label="Toggle Color Mode"
+      // aria-label="Toggle Color Mode"
       onClick={toggleColorMode}
       _focus={{ boxShadow: "none" }}
-      w="fit-content"
+      width="fit-content"
       {...props}
     >
       {colorMode === "light" ? <MdDarkModeIcon /> : <MdLightModeIcon />}
diff --git a/src/components/generic/SecBtn.tsx b/src/components/generic/SecBtn.tsx
index 4b2ae29..c46b754 100644
--- a/src/components/generic/SecBtn.tsx
+++ b/src/components/generic/SecBtn.tsx
@@ -1,17 +1,23 @@
 import { Button } from "@chakra-ui/react";
-import { FunctionalComponent, h } from "preact";
+import { h } from "preact";
 
 interface SecBtnProps {
   onClick?: any;
-  [x: string | number]: any;
+  width?: any;
+  type?: string;
+  children?: any;
+  [x: string]: any;
 }
 
-const SecBtn: FunctionalComponent<SecBtnProps> = ({ children, onClick, width, type }) => {
+export default function SecBtn({
+  children,
+  onClick,
+  width,
+  type,
+}: SecBtnProps) {
   return (
     <Button type={type} width={width} onClick={onClick}>
       {children}
     </Button>
   );
-};
-
-export default SecBtn;
+}
diff --git a/src/components/generic/SiteList/SiteListButtons.tsx b/src/components/generic/SiteList/SiteListButtons.tsx
index b215abd..fafb7fe 100644
--- a/src/components/generic/SiteList/SiteListButtons.tsx
+++ b/src/components/generic/SiteList/SiteListButtons.tsx
@@ -3,7 +3,6 @@ import {
   Tooltip,
   IconButton,
   Icon,
-  Box,
   useDisclosure,
   Button,
   Modal,
@@ -45,7 +44,12 @@ export function SiteListButtons(props: SiteListButtonProps) {
   return (
     <Fragment>
       <Flex gap={3}>
-        <Tooltip label={`Edit ${listType}`} hasArrow bg="blue.300" placement="bottom-start">
+        <Tooltip
+          label={`Edit ${listType}`}
+          hasArrow
+          bg="blue.300"
+          placement="bottom-start"
+        >
           <IconButton
             aria-label={`Edit ${listType}`}
             icon={(<Icon as={EditIcon} boxSize={7} />) as any}
@@ -58,7 +62,12 @@ export function SiteListButtons(props: SiteListButtonProps) {
           />
         </Tooltip>
 
-        <Tooltip label={`Delete ${listType}`} hasArrow bg="blue.300" placement="bottom-start">
+        <Tooltip
+          label={`Delete ${listType}`}
+          hasArrow
+          bg="blue.300"
+          placement="bottom-start"
+        >
           <IconButton
             aria-label={`Delete ${listType}`}
             icon={(<Icon as={CloseIcon} boxSize={7} />) as any}
@@ -78,7 +87,7 @@ export function SiteListButtons(props: SiteListButtonProps) {
   );
 }
 
-const OpenModal = ({ item, disclosure, children }) => {
+function OpenModal({ item, disclosure, children }) {
   return (
     <Modal isOpen={disclosure.isOpen} onClose={disclosure.onClose}>
       <ModalOverlay />
@@ -96,4 +105,4 @@ const OpenModal = ({ item, disclosure, children }) => {
       </ModalContent>
     </Modal>
   );
-};
+}
diff --git a/src/components/header/MobileNav.tsx b/src/components/header/MobileNav.tsx
index a852835..0759550 100644
--- a/src/components/header/MobileNav.tsx
+++ b/src/components/header/MobileNav.tsx
@@ -1,20 +1,20 @@
 import {
-  FlexProps,
   Flex,
-  useColorModeValue,
-  IconButton,
+  FlexProps,
+  Box,
   HStack,
-  Menu,
-  MenuButton,
-  Avatar,
   VStack,
-  Box,
-  Portal,
+  Link,
+  Text,
+  Avatar,
+  Menu,
   MenuList,
   MenuItem,
   MenuDivider,
-  Text,
-  Link,
+  MenuButton,
+  IconButton,
+  Portal,
+  useColorModeValue,
 } from "@chakra-ui/react";
 // Preact
 import { h } from "preact";
@@ -34,11 +34,7 @@ interface MobileProps extends FlexProps {
   headerTitle: string;
 }
 
-export default function MobileNav({
-  onOpen,
-  headerTitle,
-  ...rest
-}: MobileProps) {
+export default function MobileNav({ onOpen, headerTitle, ...rest }) {
   // Need to get user from the db instead
   const [user, userLoading] = useAuthState(auth);
 
diff --git a/src/components/page/Routing.tsx b/src/components/page/Routing.tsx
index a78b998..3fce0bb 100644
--- a/src/components/page/Routing.tsx
+++ b/src/components/page/Routing.tsx
@@ -1,68 +1,123 @@
-import { createContext, h } from "preact";
-import { FC } from "preact/compat";
-
+import AsyncRoute from "preact-async-route";
 import Router, { Route } from "preact-router";
-import { StateUpdater, useMemo, useState } from "preact/hooks";
-import useStorage from "../../hooks/useStorage";
-
-import Competitors from "../../routes/competitors/Competitors";
-import EventList from "../../routes/events/Event";
-import EventEdit from "../../routes/events/EventEdit";
-import Events from "../../routes/events/Events";
 import Home from "../../routes/home";
-import Import from "../../routes/import/Import";
 import NotFoundPage from "../../routes/notfound";
-import { RaceEdit } from "../../routes/races/RaceEdit";
-import Races from "../../routes/races/Races";
-
-import Result from "../../routes/results";
-// import Results from "../routes/results";
-import Series from "../../routes/series/Series";
-import SeriesEdit from "../../routes/series/SeriesEdit";
-import UserLanding from "../../routes/user/UserLanding";
-import UserProfile from "../../routes/user/UserProfile";
-import UserSettings from "../../routes/user/UserSettings";
-import { AuthRoute } from "../../util/AuthenticatedRoute ";
 import { SignIn } from "./SignIn";
 
-interface IRouting {
+interface RoutingProps {
   [x: string | number]: any;
 }
 
-const Routing: FC<IRouting> = (props) => {
+export default function Routing(props) {
   return (
     <Router>
       <Route path="/" component={Home} {...props} />
-
       <Route path="/signin" component={SignIn} {...props} />
-
-      {/* <RacesCtx.Provider value={racesContextProvider}> */}
-      <Route path="/import" component={Import} {...props} />
-      <Route
+      <AsyncRoute
+        path="/import"
+        getComponent={() =>
+          import("../../routes/import/Import").then((module) => module.default)
+        }
+        {...props}
+      />
+      <AsyncRoute
         path="/result/:seriesId/:raceId/:raceName"
-        component={Result}
+        getComponent={() =>
+          import("../../routes/results").then((module) => module.default)
+        }
         {...props}
       />
-      {/* </RacesCtx.Provider> */}
-
-      <Route path="/series" component={Series} {...props} />
-      <Route path="/series/edit" component={SeriesEdit} {...props} />
-
-      <AuthRoute path="/events" component={Events} {...props} />
-      <AuthRoute path="/events/edit" component={EventEdit} {...props} />
-      <AuthRoute path="/events/event" component={EventList} {...props} />
-
-      <Route path="/races" component={Races} {...props} />
-      <Route path="/races/edit" component={RaceEdit} {...props} />
-
-      <Route path="/competitors" component={Competitors} {...props} />
-
-      <Route path="/user" component={UserLanding} {...props} />
-      <Route path="/user/settings" component={UserSettings} {...props} />
-      <Route path="/user/profile" component={UserProfile} {...props} />
-
-      <NotFoundPage default />
+      <AsyncRoute
+        path="/series"
+        getComponent={() =>
+          import("../../routes/series/Series").then((module) => module.default)
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/series/edit"
+        getComponent={() =>
+          import("../../routes/series/SeriesEdit").then(
+            (module) => module.default
+          )
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/events"
+        getComponent={() =>
+          import("../../routes/events/Events").then((module) => module.default)
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/events/edit"
+        getComponent={() =>
+          import("../../routes/events/EventEdit").then(
+            (module) => module.default
+          )
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/events/event"
+        getComponent={() =>
+          import("../../routes/events/Event").then((module) => module.default)
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/races"
+        getComponent={() =>
+          import("../../routes/races/Races").then((module) => module.default)
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/races/edit"
+        getComponent={() =>
+          import("../../routes/races/RaceEdit").then((module) => module.default)
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/competitors"
+        getComponent={() =>
+          import("../../routes/competitors/Competitors").then(
+            (module) => module.default
+          )
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/user"
+        getComponent={() =>
+          import("../../routes/user/UserLanding").then(
+            (module) => module.default
+          )
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/user/settings"
+        getComponent={() =>
+          import("../../routes/user/UserSettings").then(
+            (module) => module.default
+          )
+        }
+        {...props}
+      />
+      <AsyncRoute
+        path="/user/profile"
+        getComponent={() =>
+          import("../../routes/user/UserProfile").then(
+            (module) => module.default
+          )
+        }
+        {...props}
+      />
+      <NotFoundPage default={true} />
     </Router>
   );
-};
-export default Routing;
+}
+// export default Routing;
diff --git a/src/components/page/app.tsx b/src/components/page/app.tsx
deleted file mode 100644
index 4ad256f..0000000
--- a/src/components/page/app.tsx
+++ /dev/null
@@ -1,28 +0,0 @@
-import { Box, ChakraProvider, extendTheme } from "@chakra-ui/react";
-import { h } from "preact";
-import { useState } from "preact/hooks";
-import { useAuthState } from "react-firebase-hooks/auth";
-import { auth } from "../../util/firebase-config";
-import SidebarWithHeader from "../header/SidebarWithHeader";
-import Routing from "./Routing";
-import { theme } from "./theme";
-
-const App = () => {
-  const [user] = useAuthState(auth);
-
-  const [headerTitle, setHeaderTitle] = useState("Blw Me");
-
-  return (
-    <div id="preact_root">
-      <ChakraProvider resetCSS theme={theme}>
-        <SidebarWithHeader headerTitle={headerTitle}>
-          <Box mt={16}>
-            <Routing user={user} setHeaderTitle={setHeaderTitle} headerTitle={headerTitle} />
-          </Box>
-        </SidebarWithHeader>
-      </ChakraProvider>
-    </div>
-  );
-};
-
-export default App;
diff --git a/src/components/page/theme.tsx b/src/components/page/theme.tsx
index 8e38dce..bd0d967 100644
--- a/src/components/page/theme.tsx
+++ b/src/components/page/theme.tsx
@@ -1,4 +1,4 @@
-import { extendTheme } from "@chakra-ui/react";
+import { extendTheme, withDefaultColorScheme } from "@chakra-ui/react";
 
 // export const theme = extendTheme({
 //   colors: {
@@ -128,7 +128,7 @@ export const components = {
     defaultProps: {
       // size: "lg", // default is md
       variant: "outline", // default is solid
-      colorScheme: "blue", // default is gray
+      // colorScheme: "blue", // default is gray
     },
   },
 };
@@ -138,4 +138,7 @@ export const fonts = {
   body: "",
 };
 
-export const theme = extendTheme({ components, colors, fonts });
+// export const theme = extendTheme(
+//   withDefaultColorScheme({ colorScheme: "blue" }),
+//   { components, colors, fonts }
+// );
diff --git a/src/index.css b/src/index.css
deleted file mode 100644
index 917888c..0000000
--- a/src/index.css
+++ /dev/null
@@ -1,70 +0,0 @@
-:root {
-  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;
-  font-size: 16px;
-  line-height: 24px;
-  font-weight: 400;
-
-  color-scheme: light dark;
-  color: rgba(255, 255, 255, 0.87);
-  background-color: #242424;
-
-  font-synthesis: none;
-  text-rendering: optimizeLegibility;
-  -webkit-font-smoothing: antialiased;
-  -moz-osx-font-smoothing: grayscale;
-  -webkit-text-size-adjust: 100%;
-}
-
-a {
-  font-weight: 500;
-  color: #646cff;
-  text-decoration: inherit;
-}
-a:hover {
-  color: #535bf2;
-}
-
-body {
-  margin: 0;
-  display: flex;
-  place-items: center;
-  min-width: 320px;
-  min-height: 100vh;
-}
-
-h1 {
-  font-size: 3.2em;
-  line-height: 1.1;
-}
-
-button {
-  border-radius: 8px;
-  border: 1px solid transparent;
-  padding: 0.6em 1.2em;
-  font-size: 1em;
-  font-weight: 500;
-  font-family: inherit;
-  background-color: #1a1a1a;
-  cursor: pointer;
-  transition: border-color 0.25s;
-}
-button:hover {
-  border-color: #646cff;
-}
-button:focus,
-button:focus-visible {
-  outline: 4px auto -webkit-focus-ring-color;
-}
-
-@media (prefers-color-scheme: light) {
-  :root {
-    color: #213547;
-    background-color: #ffffff;
-  }
-  a:hover {
-    color: #747bff;
-  }
-  button {
-    background-color: #f9f9f9;
-  }
-}
diff --git a/src/index.ts b/src/index.ts
deleted file mode 100644
index 63ac8a3..0000000
--- a/src/index.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-import "./style/index.css";
-import App from "./components/page/app";
-// Need to change this import style
-export default App;
diff --git a/src/routes/competitors/Competitors.tsx b/src/routes/competitors/Competitors.tsx
index 8cc4b54..a4d2aab 100644
--- a/src/routes/competitors/Competitors.tsx
+++ b/src/routes/competitors/Competitors.tsx
@@ -1,14 +1,34 @@
-import { Box, Container, Divider, Flex, Heading, Icon, IconButton, List, ListItem, Spinner } from "@chakra-ui/react";
+import {
+  Box,
+  Container,
+  Divider,
+  Flex,
+  Heading,
+  Icon,
+  IconButton,
+  List,
+  ListItem,
+  Spinner,
+} from "@chakra-ui/react";
 import { Fragment, h } from "preact";
 import { FadeInSlideRight } from "../../components/animations/FadeSlide";
 // import { MdLibraryAdd } from "react-icons/md";
 import AddToPhotosOutlinedIcon from "@mui/icons-material/AddToPhotosOutlined";
-import { query, collectionGroup, where, orderBy, collection } from "firebase/firestore";
+import {
+  query,
+  collectionGroup,
+  where,
+  orderBy,
+  collection,
+} from "firebase/firestore";
 import { db } from "../../util/firebase-config";
-import { useCollection, useCollectionData } from "react-firebase-hooks/firestore";
+import {
+  useCollection,
+  useCollectionData,
+} from "react-firebase-hooks/firestore";
 import { useMemo } from "preact/hooks";
 
-const Competitors = ({ user, setHeaderTitle }) => {
+export default function Competitors({ user, setHeaderTitle }) {
   setHeaderTitle("Competitors");
   // trying to get a ref for the users collections
   //   const eventRef = collection(db, "events", )
@@ -34,9 +54,7 @@ const Competitors = ({ user, setHeaderTitle }) => {
     <Fragment>
       <Flex justifyContent="space-between" alignItems="end">
         <FadeInSlideRight>
-          <Heading as="h4" color="blue.400">
-            Select Competitors
-          </Heading>
+          <Heading color="blue.400">Select Competitors</Heading>
         </FadeInSlideRight>
 
         <IconButton
@@ -63,5 +81,5 @@ const Competitors = ({ user, setHeaderTitle }) => {
       </Container>
     </Fragment>
   );
-};
-export default Competitors;
+}
+// export default Competitors;
diff --git a/src/routes/events/AddSeriesModal.tsx b/src/routes/events/AddSeriesModal.tsx
index 17e7080..3ffe596 100644
--- a/src/routes/events/AddSeriesModal.tsx
+++ b/src/routes/events/AddSeriesModal.tsx
@@ -22,7 +22,7 @@ import { FadeInSlideLeft } from "../../components/animations/FadeSlide";
 import PriBtn from "../../components/generic/PriBtn";
 import { db } from "../../util/firebase-config";
 
-const AddSeriesModal = ({ isOpen, onClose, eventId }) => {
+export default function AddSeriesModal({ isOpen, onClose, eventId }) {
   const [seriesList, setSeriesList] = useState([] as any);
 
   const serRef = collection(db, "series");
@@ -109,6 +109,6 @@ const AddSeriesModal = ({ isOpen, onClose, eventId }) => {
       </ModalContent>
     </Modal>
   );
-};
+}
 
-export default AddSeriesModal;
+// export default AddSeriesModal;
diff --git a/src/routes/events/Event.tsx b/src/routes/events/Event.tsx
index 83479ff..5462156 100644
--- a/src/routes/events/Event.tsx
+++ b/src/routes/events/Event.tsx
@@ -3,7 +3,10 @@ import { collection, doc, query, updateDoc, where } from "firebase/firestore";
 import { Fragment, h } from "preact";
 import { route } from "preact-router";
 import { useCollection, useDocumentData } from "react-firebase-hooks/firestore";
-import { FadeInSlideLeft, FadeInSlideRight } from "../../components/animations/FadeSlide";
+import {
+  FadeInSlideLeft,
+  FadeInSlideRight,
+} from "../../components/animations/FadeSlide";
 import { AreYouSure } from "../../components/generic/AreYouSure";
 import { SiteList } from "../../components/generic/SiteList";
 import { SiteListButtons } from "../../components/generic/SiteList/SiteListButtons";
@@ -45,21 +48,35 @@ export default function EventList({ setHeaderTitle }) {
         <Fragment>
           <Flex justifyContent="space-between" alignItems="end" px={4}>
             <FadeInSlideRight>
-              <Heading as="h4" color="blue.400">
-                {eventDoc.name}
-              </Heading>
+              <Heading color="blue.400">{eventDoc.name}</Heading>
             </FadeInSlideRight>
 
             {/* Sub header buttons */}
             <FadeInSlideLeft>
               <Flex gap={2}>
-                <ToolIconBtn label="Edit Event Details" action={() => route("/events/edit")} icon={EditIcon} />
-                <ToolIconBtn label="Import file" action={() => route("/import")} icon={FileUploadOutlinedIcon} />
-                <ToolIconBtn label="Add Series" action={onOpen} icon={AddToPhotosOutlinedIcon} />
+                <ToolIconBtn
+                  label="Edit Event Details"
+                  action={() => route("/events/edit")}
+                  icon={EditIcon}
+                />
+                <ToolIconBtn
+                  label="Import file"
+                  action={() => route("/import")}
+                  icon={FileUploadOutlinedIcon}
+                />
+                <ToolIconBtn
+                  label="Add Series"
+                  action={onOpen}
+                  icon={AddToPhotosOutlinedIcon}
+                />
               </Flex>
             </FadeInSlideLeft>
 
-            <AddSeriesModal isOpen={isOpen} onClose={onClose} eventId={eventId} />
+            <AddSeriesModal
+              isOpen={isOpen}
+              onClose={onClose}
+              eventId={eventId}
+            />
           </Flex>
 
           <Divider my={3} border={2} shadow={"md"} />
@@ -68,12 +85,21 @@ export default function EventList({ setHeaderTitle }) {
             {series?.docs.map((item) => {
               // console.log("item: ", item.data());
               return (
-                <SiteListItem key={item.id} item={item} disclosure={deleteEventDisclosure} listType="series">
+                <SiteListItem
+                  key={item.id}
+                  item={item}
+                  disclosure={deleteEventDisclosure}
+                  listType="series"
+                >
                   <SiteListText
                     item={item}
                     setStorage={setSeriesId}
                     forward="races"
-                    textItems={{ head: item.data().event, sub: item.data().venue, foot: item.data().venuewebsite }}
+                    textItems={{
+                      head: item.data().event,
+                      sub: item.data().venue,
+                      foot: item.data().venuewebsite,
+                    }}
                   >
                     <SiteListButtons
                       setStorage={setSeriesId}
@@ -82,8 +108,15 @@ export default function EventList({ setHeaderTitle }) {
                       disclosure={deleteEventDisclosure}
                     />
                   </SiteListText>
-                  <AreYouSure disclosure={deleteEventDisclosure} callback={removeSeries} itemId={item.id} risk="low">
-                    <Box>This action will remove this series from the event</Box>
+                  <AreYouSure
+                    disclosure={deleteEventDisclosure}
+                    callback={removeSeries}
+                    itemId={item.id}
+                    risk="low"
+                  >
+                    <Box>
+                      This action will remove this series from the event
+                    </Box>
                     <Box>You can always add this back if you want</Box>
                   </AreYouSure>
                 </SiteListItem>
diff --git a/src/routes/events/EventEdit.tsx b/src/routes/events/EventEdit.tsx
index 1f580ca..1fd8adf 100644
--- a/src/routes/events/EventEdit.tsx
+++ b/src/routes/events/EventEdit.tsx
@@ -1,4 +1,14 @@
-import { Box, Button, Divider, Flex, FormLabel, forwardRef, Heading, Input, useToast } from "@chakra-ui/react";
+import {
+  Box,
+  Button,
+  Divider,
+  Flex,
+  FormLabel,
+  forwardRef,
+  Heading,
+  Input,
+  useToast,
+} from "@chakra-ui/react";
 import { Fragment, h } from "preact";
 import { route } from "preact-router";
 import { useEffect, useRef } from "preact/hooks";
@@ -56,9 +66,7 @@ export default function EventEdit({ user, setHeaderTitle }) {
     <Fragment>
       <Flex justifyContent="space-between" alignItems="end" px={4}>
         <FadeInSlideRight>
-          <Heading as="h4" color="blue.400">
-            Event Edit
-          </Heading>
+          <Heading color="blue.400">Event Edit</Heading>
         </FadeInSlideRight>
 
         <Flex gap={2}>
@@ -70,7 +78,11 @@ export default function EventEdit({ user, setHeaderTitle }) {
             }}
             icon={DeleteIcon}
           />
-          <ToolIconBtn label="Clear form" action={() => {}} icon={ClearAllIcon} />
+          <ToolIconBtn
+            label="Clear form"
+            action={() => {}}
+            icon={ClearAllIcon}
+          />
         </Flex>
       </Flex>
 
diff --git a/src/routes/events/Events.tsx b/src/routes/events/Events.tsx
index 76c0472..9d5a09a 100644
--- a/src/routes/events/Events.tsx
+++ b/src/routes/events/Events.tsx
@@ -1,9 +1,21 @@
-import { Box, Divider, Flex, Heading, Icon, IconButton, Tooltip, useDisclosure } from "@chakra-ui/react";
+import {
+  Box,
+  Divider,
+  Flex,
+  Heading,
+  Icon,
+  IconButton,
+  Tooltip,
+  useDisclosure,
+} from "@chakra-ui/react";
 import { addDoc, collection, query, where } from "firebase/firestore";
 import { Fragment, h } from "preact";
 import { route } from "preact-router";
 import { useCollection } from "react-firebase-hooks/firestore";
-import { FadeInSlideLeft, FadeInSlideRight } from "../../components/animations/FadeSlide";
+import {
+  FadeInSlideLeft,
+  FadeInSlideRight,
+} from "../../components/animations/FadeSlide";
 import { AreYouSure } from "../../components/generic/AreYouSure";
 import useStorage from "../../hooks/useStorage";
 import { db } from "../../util/firebase-config";
@@ -40,16 +52,22 @@ export default function Events({ user, setHeaderTitle }) {
     <Fragment>
       <Flex justifyContent="space-between" alignItems="end" px={4}>
         <FadeInSlideRight>
-          <Heading as="h4" color="blue.400">
-            All Events
-          </Heading>
+          <Heading color="blue.400">All Events</Heading>
         </FadeInSlideRight>
 
         {/* Sub header buttons */}
         <FadeInSlideLeft>
           <Flex gap={2}>
-            <ToolIconBtn label="Import file" action={() => route("/import")} icon={FileUploadOutlinedIcon} />
-            <ToolIconBtn label="Add Series" action={addEventHandler} icon={AddToPhotosOutlinedIcon} />
+            <ToolIconBtn
+              label="Import file"
+              action={() => route("/import")}
+              icon={FileUploadOutlinedIcon}
+            />
+            <ToolIconBtn
+              label="Add Series"
+              action={addEventHandler}
+              icon={AddToPhotosOutlinedIcon}
+            />
           </Flex>
         </FadeInSlideLeft>
       </Flex>
@@ -61,12 +79,21 @@ export default function Events({ user, setHeaderTitle }) {
           const data = item.data();
           // setEventId(item.id);
           return (
-            <SiteListItem key={item.id} item={item} disclosure={deleteEventDisclosure} listType="series">
+            <SiteListItem
+              key={item.id}
+              item={item}
+              disclosure={deleteEventDisclosure}
+              listType="series"
+            >
               <SiteListText
                 item={item}
                 setStorage={setEventId}
                 forward="events/event"
-                textItems={{ head: data.name, sub: data.venue, foot: data.date }}
+                textItems={{
+                  head: data.name,
+                  sub: data.venue,
+                  foot: data.date,
+                }}
               >
                 <SiteListButtons
                   setStorage={setEventId}
@@ -75,7 +102,9 @@ export default function Events({ user, setHeaderTitle }) {
                   disclosure={deleteEventDisclosure}
                 >
                   <Box>This will delete the event and is not undo-able</Box>
-                  <Box>You will loose any work you have done with this Event</Box>
+                  <Box>
+                    You will loose any work you have done with this Event
+                  </Box>
                   {/* <Box>{item.id}</Box> */}
                 </SiteListButtons>
               </SiteListText>
diff --git a/src/routes/home/index.tsx b/src/routes/home/index.tsx
index f6279c4..b22fbba 100644
--- a/src/routes/home/index.tsx
+++ b/src/routes/home/index.tsx
@@ -1,13 +1,27 @@
-import { Box, Divider, Flex, Heading, Image, ListItem, Progress, Text, UnorderedList } from "@chakra-ui/react";
+import {
+  Box,
+  Divider,
+  Flex,
+  Heading,
+  Image,
+  ListItem,
+  Progress,
+  Text,
+  UnorderedList,
+} from "@chakra-ui/react";
+import homeImg from "../../assets/img/homePage.jpeg";
 import { Fragment, h } from "preact";
 import { Link } from "preact-router";
 import { useAuthState } from "react-firebase-hooks/auth";
-import { FadeInSlideLeft, FadeInSlideRight } from "../../components/animations/FadeSlide";
+import {
+  FadeInSlideLeft,
+  FadeInSlideRight,
+} from "../../components/animations/FadeSlide";
 import { SignIn } from "../../components/page/SignIn";
 import { SignOut } from "../../components/page/SignOut";
 import { auth } from "../../util/firebase-config";
 
-const Home = ({ setHeaderTitle }) => {
+export default function Home({ setHeaderTitle }) {
   const [user, userLoading, _userError] = useAuthState(auth);
 
   setHeaderTitle("Home");
@@ -34,10 +48,12 @@ const Home = ({ setHeaderTitle }) => {
           <Divider my={3} />
 
           <Text fontSize="md">
-            <Image src="../assets/img/homePage.jpeg" boxSize="180px" float={"right"} />
-            On The Water Scoring (OTW) is sailboat racing scoring application and companion for the popular Sailwave
-            desktop application. You can Import sailwave .blw files and use them directly in the app. I have added the
-            event collection to help organize your series'. We recommend to start with this.
+            <Image src={homeImg} boxSize="180px" float={"right"} />
+            On The Water Scoring (OTW) is sailboat racing scoring application
+            and companion for the popular Sailwave desktop application. You can
+            Import sailwave .blw files and use them directly in the app. I have
+            added the event collection to help organize your series'. We
+            recommend to start with this.
           </Text>
         </Box>
       </FadeInSlideRight>
@@ -47,9 +63,7 @@ const Home = ({ setHeaderTitle }) => {
       ) : (
         <Box px={4} mb={10}>
           <Divider my={5} />
-          <Heading as="h4" fontSize={"lg"}>
-            Where too from here
-          </Heading>
+          <Heading fontSize={"lg"}>Where too from here</Heading>
           <UnorderedList spacing={1} mt={2}>
             <ListItem>
               <Link href="/import">
@@ -71,6 +85,6 @@ const Home = ({ setHeaderTitle }) => {
       )}
     </Fragment>
   );
-};
+}
 
-export default Home;
+// export default Home;
diff --git a/src/routes/import/DuplicateOptions.tsx b/src/routes/import/DuplicateOptions.tsx
index 0cdc6bd..8b03984 100644
--- a/src/routes/import/DuplicateOptions.tsx
+++ b/src/routes/import/DuplicateOptions.tsx
@@ -1,5 +1,5 @@
 import { h } from "preact";
-import { HStack, Stack, useRadioGroup } from "@chakra-ui/react";
+import { Box, HStack, Stack, useRadioGroup } from "@chakra-ui/react";
 import { IconRadio } from "./IconRadio";
 // Icons
 import ContentCopyIcon from "@mui/icons-material/ContentCopy";
@@ -24,7 +24,7 @@ export function DuplicateOptions({ item, setCopy }) {
   });
 
   return (
-    <Stack {...getRootProps()}>
+    <Stack {...(getRootProps() as any)}>
       <HStack>
         <IconRadio
           label="Make a copy"
diff --git a/src/routes/import/IconRadio.tsx b/src/routes/import/IconRadio.tsx
index 1d1c97d..5788a26 100644
--- a/src/routes/import/IconRadio.tsx
+++ b/src/routes/import/IconRadio.tsx
@@ -9,13 +9,13 @@ export function IconRadio(props) {
   return (
     <Tooltip label={label} hasArrow bg="blue.300" placement="bottom-start">
       <chakra.label {...htmlProps} cursor="pointer">
-        <Input {...getInputProps({})} hidden />
+        <Input {...(getInputProps({}) as any)} hidden />
 
         <Icon
           as={icon}
           color={state.isChecked ? "limegreen" : "gray.400"}
           bg={state.isChecked ? "green:100" : ""}
-          {...getLabelProps()}
+          {...(getLabelProps() as any)}
         />
       </chakra.label>
     </Tooltip>
diff --git a/src/routes/import/Import.tsx b/src/routes/import/Import.tsx
index a1e8467..9491311 100644
--- a/src/routes/import/Import.tsx
+++ b/src/routes/import/Import.tsx
@@ -1,6 +1,5 @@
-import { h } from "preact";
-import { route } from "preact-router";
-import { useEffect, useRef, useState } from "preact/hooks";
+import { Box, Divider, Flex, Heading, Text } from "@chakra-ui/react";
+import fileDialog from "file-dialog";
 import {
   collection,
   deleteDoc,
@@ -8,30 +7,18 @@ import {
   query,
   where,
 } from "firebase/firestore";
+import { route } from "preact-router";
+import { useEffect, useRef, useState } from "preact/hooks";
 import { useAuthState } from "react-firebase-hooks/auth";
 import { auth, db } from "../../util/firebase-config";
-import {
-  background,
-  border,
-  Box,
-  Button,
-  ButtonGroup,
-  Divider,
-  Flex,
-  Heading,
-  Text,
-} from "@chakra-ui/react";
-import fileDialog from "file-dialog";
 //
 import PriBtn from "../../components/generic/PriBtn";
+import SecBtn from "../../components/generic/SecBtn";
 import ImportList from "./ImportList";
 import { importFileObj } from "./importTypes";
 import { Populate } from "./populate";
-import SecBtn from "../../components/generic/SecBtn";
-import BtnGrp from "../../components/generic/ButtonGroup";
-import { Form, Formik } from "formik";
 
-const Import = ({ setHeaderTitle }) => {
+export default function Import({ setHeaderTitle }) {
   setHeaderTitle("Import");
 
   const [user] = useAuthState(auth);
@@ -271,7 +258,7 @@ const Import = ({ setHeaderTitle }) => {
           //     );
           //   }}
           // </Formik> */}
-          <Text as="p">
+          <Text>
             Use the choose files button to select your Sailwave file(s) to
             import
           </Text>
@@ -280,6 +267,6 @@ const Import = ({ setHeaderTitle }) => {
       )}
     </Box>
   );
-};
+}
 
-export default Import;
+// Import;
diff --git a/src/routes/import/ImportList.tsx b/src/routes/import/ImportList.tsx
index 80803b1..9d4c245 100644
--- a/src/routes/import/ImportList.tsx
+++ b/src/routes/import/ImportList.tsx
@@ -30,7 +30,7 @@ export default function ImportList({
         }) && (
           <Box my={3}>
             <Box>
-              <Heading as="h3" color="blue.300" fontSize="lg">
+              <Heading color="blue.300" fontSize="lg">
                 {duplicates ? "Duplicate files" : "New Files"}
               </Heading>
               <Divider my={3} />
diff --git a/src/routes/notfound/index.tsx b/src/routes/notfound/index.tsx
index cb8e226..1893c8c 100644
--- a/src/routes/notfound/index.tsx
+++ b/src/routes/notfound/index.tsx
@@ -10,15 +10,14 @@ import { h } from "preact";
 import { Link } from "preact-router/match";
 import ArrowBackIcon from "@mui/icons-material/ArrowBack";
 
-export default function Notfound() {
+export default function Notfound(props) {
+  //
   return (
     <Box m={8}>
       <Heading color={useColorModeValue("blue.400", "blue.200")}>
         Error 404
       </Heading>
-      <Text as="h3" color="gray.400">
-        That page doesn&apos;t exist.
-      </Text>
+      <Text color="gray.400">That page doesn&apos;t exist.</Text>
       <Link
         href="#"
         onClick={() => {
diff --git a/src/routes/profile/index.tsx b/src/routes/profile/index.tsx
index 023b56c..8c731e4 100644
--- a/src/routes/profile/index.tsx
+++ b/src/routes/profile/index.tsx
@@ -1,44 +1,6 @@
-import { FunctionalComponent, h } from 'preact';
-import { useEffect, useState } from 'preact/hooks';
-import style from './style.css';
+import { Fragment, h } from "preact";
 
-interface Props {
-    user: string;
+export default function Profile(props) {
+  const { user } = props;
+  return <Fragment>{user}</Fragment>;
 }
-
-const Profile: FunctionalComponent<Props> = (props: Props) => {
-    const { user } = props;
-    const [time, setTime] = useState<number>(Date.now());
-    const [count, setCount] = useState<number>(0);
-
-    // gets called when this route is navigated to
-    useEffect(() => {
-        const timer = window.setInterval(() => setTime(Date.now()), 1000);
-
-        // gets called just before navigating away from the route
-        return (): void => {
-            clearInterval(timer);
-        };
-    }, []);
-
-    // update the current time
-    const increment = (): void => {
-        setCount(count + 1);
-    };
-
-    return (
-        <div class={style.profile}>
-            <h1>Profile: {user}</h1>
-            <p>This is the user profile for a user named {user}.</p>
-
-            <div>Current time: {new Date(time).toLocaleString()}</div>
-
-            <p>
-                <button onClick={increment}>Click Me</button> Clicked {count}{' '}
-                times.
-            </p>
-        </div>
-    );
-};
-
-export default Profile;
diff --git a/src/routes/profile/style.css b/src/routes/profile/style.css
deleted file mode 100644
index fcb1296..0000000
--- a/src/routes/profile/style.css
+++ /dev/null
@@ -1,5 +0,0 @@
-.profile {
-	padding: 56px 20px;
-	min-height: 100%;
-	width: 100%;
-}
diff --git a/src/routes/races/RaceEdit.tsx b/src/routes/races/RaceEdit.tsx
index 474862c..2c1a7d0 100644
--- a/src/routes/races/RaceEdit.tsx
+++ b/src/routes/races/RaceEdit.tsx
@@ -34,7 +34,7 @@ import PriBtn from "../../components/generic/PriBtn";
 import SecBtn from "../../components/generic/SecBtn";
 // import style from "./style.css";
 
-export const RaceEdit = ({ setHeaderTitle }) => {
+export default function RaceEdit({ setHeaderTitle }) {
   setHeaderTitle("Edit Race");
 
   interface IraceStarts {
@@ -133,7 +133,7 @@ export const RaceEdit = ({ setHeaderTitle }) => {
                 >
                   {/* This is the header with race name or number */}
                   <FadeInSlideRight>
-                    <Heading as="h5" color="blue.400">
+                    <Heading color="blue.400">
                       <Editable
                         defaultValue={
                           currentRace?.name
@@ -144,10 +144,11 @@ export const RaceEdit = ({ setHeaderTitle }) => {
                       >
                         <EditablePreview />
                         <EditableInput
-                          onChange={({ target }) => {
-                            setRaceName(target.value);
+                          onChange={({ target }: any) => {
+                            setRaceName(target?.value);
                           }}
                         />
+                        {/*  */}
                       </Editable>
                     </Heading>
                     <Text fontSize="sm" color="lightgray">
@@ -214,4 +215,4 @@ export const RaceEdit = ({ setHeaderTitle }) => {
       )}
     </Fragment>
   );
-};
+}
diff --git a/src/routes/races/Races.tsx b/src/routes/races/Races.tsx
index b164fb2..a30856d 100644
--- a/src/routes/races/Races.tsx
+++ b/src/routes/races/Races.tsx
@@ -61,7 +61,7 @@ export default function Races(props) {
       <Box pb={4}>
         <Flex justifyContent="space-between" alignItems="end" px={6}>
           <FadeInSlideRight>
-            <Heading as="h4" color="blue.400">
+            <Heading color="blue.400">
               <Link href="/series/edit">{series && series.event}</Link>
             </Heading>
           </FadeInSlideRight>
diff --git a/src/routes/races/__RacesList.tsx b/src/routes/races/__RacesList.tsx
index 138eb9a..bf957d0 100644
--- a/src/routes/races/__RacesList.tsx
+++ b/src/routes/races/__RacesList.tsx
@@ -18,7 +18,10 @@ import { db } from "../../util/firebase-config";
 import { useCollection } from "react-firebase-hooks/firestore";
 import useStorage from "../../hooks/useStorage";
 import { formatDate } from "../../util/formatters";
-import { FadeInSlideLeft, FadeInSlideRight } from "../../components/animations/FadeSlide";
+import {
+  FadeInSlideLeft,
+  FadeInSlideRight,
+} from "../../components/animations/FadeSlide";
 import style from "./style.css";
 // Icons
 import AddIcon from "@mui/icons-material/Add";
@@ -44,7 +47,14 @@ const ___RacesList = ({ setHeaderTitle }) => {
     <Fragment>
       <Container>
         <FadeInSlideRight>
-          <Heading as="h3" color="blue.400" position={"fixed"} w="100%" mt={2} pb={3} zIndex="+1">
+          <Heading
+            color="blue.400"
+            position={"fixed"}
+            w="100%"
+            mt={2}
+            pb={3}
+            zIndex="+1"
+          >
             Select a race
           </Heading>
         </FadeInSlideRight>
@@ -53,7 +63,13 @@ const ___RacesList = ({ setHeaderTitle }) => {
           {/* Loading Spinner */}
           {racesLoading ? (
             <Flex justifyContent=" center" alignItems="center">
-              <Spinner thickness="4px" speed="0.65s" emptyColor="gray.200" color="blue.500" size="xl" />
+              <Spinner
+                thickness="4px"
+                speed="0.65s"
+                emptyColor="gray.200"
+                color="blue.500"
+                size="xl"
+              />
             </Flex>
           ) : (
             // Races loaded make a list
@@ -65,9 +81,17 @@ const ___RacesList = ({ setHeaderTitle }) => {
                     <Flex alignItems="center">
                       {/* Icon for row */}
                       {race.data().sailed === "1" ? (
-                        <Icon as={CheckCircleIcon} color="gray.400" boxSize={3} />
+                        <Icon
+                          as={CheckCircleIcon}
+                          color="gray.400"
+                          boxSize={3}
+                        />
                       ) : race.data().sailed === "cancelled" ? (
-                        <Icon as={DoNotDisturbIcon} color="gray.400" boxSize={3} />
+                        <Icon
+                          as={DoNotDisturbIcon}
+                          color="gray.400"
+                          boxSize={3}
+                        />
                       ) : race.data().sailed === "postponed" ? (
                         <Icon as={CalendarIcon} color="gray.400" boxSize={3} />
                       ) : (
@@ -75,7 +99,11 @@ const ___RacesList = ({ setHeaderTitle }) => {
                       )}
 
                       {/* If Name else R+N */}
-                      <Text px={3}>{race.data().name ? race.data().name : `Race ${race.data().rank}`}</Text>
+                      <Text px={3}>
+                        {race.data().name
+                          ? race.data().name
+                          : `Race ${race.data().rank}`}
+                      </Text>
 
                       <Text color="gray.400" px={3} fontSize="xs">
                         {/* Change the sailwave number to sailed or not and  */}
@@ -136,10 +164,16 @@ const ___RacesList = ({ setHeaderTitle }) => {
                             aria-label="View results "
                             colorScheme="blue"
                             size="xs"
-                            icon={(<Icon as={VisibilityIcon} boxSize={4} />) as any}
+                            icon={
+                              (<Icon as={VisibilityIcon} boxSize={4} />) as any
+                            }
                             disabled={race.data().sailed !== "1"}
                             onClick={({ target }) => {
-                              route(`/result/${race.data()._seriesid}/${race.data().raceid}`);
+                              route(
+                                `/result/${race.data()._seriesid}/${
+                                  race.data().raceid
+                                }`
+                              );
                             }}
                           />
                         </span>
diff --git a/src/routes/races/raceEdit/AddStartModal.tsx b/src/routes/races/raceEdit/AddStartModal.tsx
index cdb5d22..ee183e7 100644
--- a/src/routes/races/raceEdit/AddStartModal.tsx
+++ b/src/routes/races/raceEdit/AddStartModal.tsx
@@ -14,7 +14,7 @@ import {
 import { arrayUnion, updateDoc } from "firebase/firestore";
 import { Form, useFormik } from "formik";
 
-export const AddStartModal = ({ isOpen, onClose, docRef }) => {
+export function AddStartModal({ isOpen, onClose, docRef }) {
   const upDate = async (start) => {
     await updateDoc(docRef, { starts: arrayUnion(start) });
   };
@@ -38,22 +38,40 @@ export const AddStartModal = ({ isOpen, onClose, docRef }) => {
         <ModalCloseButton />
         <ModalBody>
           <Form onSubmit={formik.handleSubmit}>
-            <Input type="text" name="startName" onChange={formik.handleChange} value={formik.values.startName} />
+            <Input
+              type="text"
+              name="startName"
+              onChange={formik.handleChange}
+              value={formik.values.startName}
+            />
 
             <Divider mt={3} />
 
-            <Input type="time" name="startTime" onChange={formik.handleChange} value={formik.values.startTime} />
+            <Input
+              type="time"
+              name="startTime"
+              onChange={formik.handleChange}
+              value={formik.values.startTime}
+            />
 
             <Divider mt={3} />
 
-            <Button type="submit" colorScheme="blue" mr={3} w="100%" onClick={onClose}>
+            <Button
+              type="submit"
+              colorScheme="blue"
+              mr={3}
+              w="100%"
+              onClick={onClose}
+            >
               Add
             </Button>
           </Form>
         </ModalBody>
 
-        <ModalFooter>{/* <Button variant='ghost' onClick={onClose}>Cancel</Button> */}</ModalFooter>
+        <ModalFooter>
+          {/* <Button variant='ghost' onClick={onClose}>Cancel</Button> */}
+        </ModalFooter>
       </ModalContent>
     </Modal>
   );
-};
+}
diff --git a/src/routes/races/raceEdit/Date.tsx b/src/routes/races/raceEdit/Date.tsx
index 494841f..25c7355 100644
--- a/src/routes/races/raceEdit/Date.tsx
+++ b/src/routes/races/raceEdit/Date.tsx
@@ -2,7 +2,7 @@ import { Box, FormControl, FormLabel, Input } from "@chakra-ui/react";
 import { Field } from "formik";
 import { Fragment, h } from "preact";
 
-export const Date = () => {
+export function Date() {
   return (
     <Fragment>
       <Box>
@@ -13,4 +13,4 @@ export const Date = () => {
       </Box>
     </Fragment>
   );
-};
+}
diff --git a/src/routes/races/raceEdit/FirstGun.tsx b/src/routes/races/raceEdit/FirstGun.tsx
index 03ea023..c4375e7 100644
--- a/src/routes/races/raceEdit/FirstGun.tsx
+++ b/src/routes/races/raceEdit/FirstGun.tsx
@@ -5,7 +5,7 @@ import { updateDoc } from "firebase/firestore";
 import { Field } from "formik";
 import SecBtn from "../../../components/generic/SecBtn";
 
-export const FirstGun = ({ docRef, setRaceTime }) => {
+export function FirstGun({ docRef, setRaceTime }) {
   const handleSetTime = async () => {
     const theDate = Temporal.Now.plainTimeISO();
     await updateDoc(docRef, { time: `${theDate.round("minutes")}` });
@@ -24,4 +24,4 @@ export const FirstGun = ({ docRef, setRaceTime }) => {
       </Box>
     </Fragment>
   );
-};
+}
diff --git a/src/routes/races/raceEdit/Notes.tsx b/src/routes/races/raceEdit/Notes.tsx
index 79ed41f..62674fe 100644
--- a/src/routes/races/raceEdit/Notes.tsx
+++ b/src/routes/races/raceEdit/Notes.tsx
@@ -2,7 +2,7 @@ import { FormLabel, Textarea } from "@chakra-ui/react";
 import { Field } from "formik";
 import { Fragment, h } from "preact";
 
-export const Notes = ({ loading, currentRace }) => {
+export function Notes({ loading, currentRace }) {
   return (
     <Fragment>
       <FormLabel htmlFor="notes">Notes</FormLabel>
@@ -11,4 +11,4 @@ export const Notes = ({ loading, currentRace }) => {
       </Field>
     </Fragment>
   );
-};
+}
diff --git a/src/routes/races/raceEdit/ResultType.tsx b/src/routes/races/raceEdit/ResultType.tsx
index f21aab8..09ab9fd 100644
--- a/src/routes/races/raceEdit/ResultType.tsx
+++ b/src/routes/races/raceEdit/ResultType.tsx
@@ -9,7 +9,7 @@ import {
 import { Field } from "formik";
 import { h } from "preact";
 
-export const ResultType = () => {
+export function ResultType() {
   return (
     <Field name="resultType">
       {({ field, form }) => (
@@ -33,4 +33,4 @@ export const ResultType = () => {
       )}
     </Field>
   );
-};
+}
diff --git a/src/routes/races/raceEdit/Sailed.tsx b/src/routes/races/raceEdit/Sailed.tsx
index df83e01..6edee4b 100644
--- a/src/routes/races/raceEdit/Sailed.tsx
+++ b/src/routes/races/raceEdit/Sailed.tsx
@@ -22,11 +22,11 @@ interface ISailedProps {
   currentRace?: any;
 }
 
-export const Sailed = ({
+export function Sailed({
   postponedDate,
   setPostponedDate,
   currentRace,
-}: ISailedProps) => {
+}: ISailedProps) {
   return (
     <Box>
       <Field name="sailed">
@@ -111,4 +111,4 @@ export const Sailed = ({
       </Field>
     </Box>
   );
-};
+}
diff --git a/src/routes/races/raceEdit/Starts.tsx b/src/routes/races/raceEdit/Starts.tsx
index d649f09..844e1b1 100644
--- a/src/routes/races/raceEdit/Starts.tsx
+++ b/src/routes/races/raceEdit/Starts.tsx
@@ -25,7 +25,7 @@ import { AddStartModal } from "./AddStartModal";
 import AddIcon from "@mui/icons-material/Add";
 import CloseIcon from "@mui/icons-material/Close";
 
-export const Starts = ({ raceStarts, docRef, values }) => {
+export function Starts({ raceStarts, docRef, values }) {
   const { isOpen, onOpen, onClose } = useDisclosure();
 
   const [starts, setStarts] = useState<[{ fleet: string; start: string }]>();
@@ -116,4 +116,4 @@ export const Starts = ({ raceStarts, docRef, values }) => {
       </FieldArray>
     </Fragment>
   );
-};
+}
diff --git a/src/routes/races/racesView/EditButtons.tsx b/src/routes/races/racesView/EditButtons.tsx
index 15ad9f8..f1fe0a2 100644
--- a/src/routes/races/racesView/EditButtons.tsx
+++ b/src/routes/races/racesView/EditButtons.tsx
@@ -1,4 +1,11 @@
-import { Box, Flex, Icon, IconButton, Tooltip, useDisclosure } from "@chakra-ui/react";
+import {
+  Box,
+  Flex,
+  Icon,
+  IconButton,
+  Tooltip,
+  useDisclosure,
+} from "@chakra-ui/react";
 import { Fragment, h } from "preact";
 import { route } from "preact-router";
 import { AreYouSure } from "../../../components/generic/AreYouSure";
@@ -32,7 +39,6 @@ export default function EditButtons({ setRaceId, race }) {
           <IconButton
             aria-label="Edit race settings"
             variant={"ghost"}
-            colorScheme="blue"
             icon={(<Icon as={EditIcon} boxSize={7} />) as any}
             onClick={() => {
               setRaceId(race.id);
@@ -40,17 +46,26 @@ export default function EditButtons({ setRaceId, race }) {
             }}
           />
         </Tooltip>
-        <Tooltip label="Delete Series" hasArrow bg="blue.300" placement="bottom-start">
+        <Tooltip
+          label="Delete Series"
+          hasArrow
+          bg="blue.300"
+          placement="bottom-start"
+        >
           <IconButton
             aria-label="Delete series"
             variant="ghost"
-            colorScheme="blue"
+            // colorScheme="blue"
             icon={(<Icon as={CloseIcon} boxSize={7} />) as any}
             onClick={deleteRaceDisclosure.onOpen}
           />
         </Tooltip>
       </Flex>
-      <AreYouSure disclosure={deleteRaceDisclosure} colPath={`/series/${seriesId}/races`} itemId={race.id}>
+      <AreYouSure
+        disclosure={deleteRaceDisclosure}
+        colPath={`/series/${seriesId}/races`}
+        itemId={race.id}
+      >
         <Box>This will permanently delete the race and can not be un-done</Box>
         <Box>You will loose any work you have done with this race</Box>
         <Box>{race.id}</Box>
diff --git a/src/routes/races/racesView/StartTheRaceModal.tsx b/src/routes/races/racesView/StartTheRaceModal.tsx
index 2a0e107..7e07dbc 100644
--- a/src/routes/races/racesView/StartTheRaceModal.tsx
+++ b/src/routes/races/racesView/StartTheRaceModal.tsx
@@ -2,8 +2,6 @@ import {
   Box,
   Button,
   Flex,
-  Icon,
-  IconButton,
   Modal,
   ModalBody,
   ModalCloseButton,
@@ -14,9 +12,12 @@ import {
   Text,
   useColorModeValue,
 } from "@chakra-ui/react";
-import CloseIcon from "@mui/icons-material/Close";
-import { ComponentChildren, Fragment, h } from "preact";
-import { formatDate, formatRelativeDate, formatTime } from "../../../util/formatters";
+import { ComponentChildren, Fragment } from "preact";
+import {
+  formatDate,
+  formatRelativeDate,
+  formatTime,
+} from "../../../util/formatters";
 
 interface SartTheRaceProps {
   disclosure: {
@@ -32,14 +33,20 @@ interface SartTheRaceProps {
   callback?: (id: string) => Promise<void>;
   children?: ComponentChildren;
 }
-export default function StartTheRaceModal({ disclosure, race, callback }: SartTheRaceProps) {
+export default function StartTheRaceModal({
+  disclosure,
+  race,
+  callback,
+}: SartTheRaceProps) {
   const { isOpen, onClose } = disclosure;
 
   const timeDifference = () => {
-    if (!race.data().date || race.data().time) {
+    if (!race.data().date || !race.data().time) {
       return;
     }
-    const then = new Date(`${formatDate(race.data().date)} ${formatTime(race.data().time)}`);
+    const then = new Date(
+      `${formatDate(race.data().date)} ${formatTime(race.data().time)}`
+    );
     return formatRelativeDate(then);
   };
 
@@ -48,7 +55,9 @@ export default function StartTheRaceModal({ disclosure, race, callback }: SartTh
       <Modal isOpen={isOpen} onClose={onClose} size="sm">
         <ModalOverlay bg="none" backdropFilter="auto" backdropBlur="2px" />
         <ModalContent>
-          <ModalHeader bgColor={useColorModeValue("blackAlpha.200", "blackAlpha.500")}>
+          <ModalHeader
+            bgColor={useColorModeValue("blackAlpha.200", "blackAlpha.500")}
+          >
             <Text fontSize="2xl">Start the Race</Text>
           </ModalHeader>
           <ModalCloseButton />
@@ -57,12 +66,17 @@ export default function StartTheRaceModal({ disclosure, race, callback }: SartTh
               <Text fontSize="2xl">{race.data().name}</Text>
               <Text>
                 This Race is scheduled to start{" "}
-                <Text fontWeight={"bold"}>{race && race.data() && timeDifference()}</Text>
+                <Text fontWeight={"bold"}>
+                  {race && race.data() && timeDifference()}
+                </Text>
                 <Text>
                   {" "}
-                  at {race.data().time} on {new Date(formatDate(race.data().date)).toDateString()}
+                  at {race.data().time} on{" "}
+                  {new Date(formatDate(race.data().date)).toDateString()}
+                </Text>
+                <Text>
+                  To use the On the Water Scoring App select one from below
                 </Text>
-                <Text>To use the On the Water Scoring App select one from below</Text>
               </Text>
             </Box>
             <Flex gap={2} justify={"end"}>
@@ -76,14 +90,12 @@ export default function StartTheRaceModal({ disclosure, race, callback }: SartTh
               >
                 Now
               </Button>
-              <Button colorScheme="blue" onClick={onClose}>
-                Scheduled
-              </Button>
+              <Button onClick={onClose}>Scheduled</Button>
             </Flex>
           </ModalBody>
 
           <ModalFooter>
-            <Button colorScheme="blue" variant="outline" onClick={onClose}>
+            <Button variant="outline" onClick={onClose}>
               Enter results manually
             </Button>
           </ModalFooter>
diff --git a/src/routes/results/components/FleetsTables.tsx b/src/routes/results/components/FleetsTables.tsx
index 81b322e..1fc276e 100644
--- a/src/routes/results/components/FleetsTables.tsx
+++ b/src/routes/results/components/FleetsTables.tsx
@@ -1,7 +1,6 @@
 import { Fragment, h } from "preact";
-import { Divider, Text } from "@chakra-ui/react";
+import { Divider } from "@chakra-ui/react";
 import ResultTable from "./ResultTable";
-import { useEffect } from "preact/hooks";
 
 export default function FleetsTable(props) {
   const { tableData, ...rest } = props;
@@ -10,16 +9,15 @@ export default function FleetsTable(props) {
   const unique = Array.from(
     new Set(
       tableData.map((item) => {
-        if (item.fleet && item.division) {
-          return `${item.fleet} - ${item.division}`;
-        }
+        // Still have to work out how to deal with
+        // races with Fleets and division. ie: NFS div1
         if (item.division) return item.division;
 
         return item.fleet;
       })
     )
   );
-
+  // console.log("unique: ", unique);
   unique.forEach((fleetName) => {
     const push = tableData.filter((td) => {
       if (td.fleet && td.fleet === fleetName) return td;
@@ -27,7 +25,10 @@ export default function FleetsTable(props) {
         td.fleet = td.division;
         return td;
       }
+      // return Fleet if there is no fleet defined
+      if (!td.fleet || td.division) return "Fleet";
     });
+
     fleetsArray.push(push);
   });
 
@@ -35,9 +36,14 @@ export default function FleetsTable(props) {
     <Fragment>
       {fleetsArray &&
         fleetsArray.sort().map((fleet) => {
+          console.log("fleet: ", fleet);
           return (
             <Fragment>
-              <ResultTable tableData={fleet} fleetName={fleet[0].fleet} {...rest} />
+              <ResultTable
+                tableData={fleet}
+                fleetName={fleet[0].fleet}
+                {...rest}
+              />
               <Divider mb={4} mt={8} />
             </Fragment>
           );
diff --git a/src/routes/results/components/ResultTable.tsx b/src/routes/results/components/ResultTable.tsx
index a014c15..741bfa2 100644
--- a/src/routes/results/components/ResultTable.tsx
+++ b/src/routes/results/components/ResultTable.tsx
@@ -7,16 +7,10 @@ import {
   Heading,
   Icon,
   Image,
-  Progress,
   Spinner,
   Text,
 } from "@chakra-ui/react";
-import {
-  Editable,
-  EditableInput,
-  EditableTextarea,
-  EditablePreview,
-} from "@chakra-ui/react";
+import { Editable, EditableInput, EditablePreview } from "@chakra-ui/react";
 // Chakra hooks
 import {
   useColorModeValue,
@@ -53,7 +47,7 @@ import ChevronLeftIcon from "@mui/icons-material/ChevronLeft";
 import ChevronRightIcon from "@mui/icons-material/ChevronRight";
 import ToolIconBtn from "../../../components/generic/ToolIconBtn";
 import { DocumentData } from "firebase/firestore";
-import { checkIfSailed } from "../../races/racesView/checkIfRaceSailed";
+import spacer from "../../../assets/img/spacer.gif";
 
 type ResultRow = {
   id: number;
@@ -116,6 +110,7 @@ function FleetTable(props: TableProps) {
     ...rest
   } = props;
 
+  // console.log("race: ", race);
   // States
   const [columnVisibility, setColumnVisibility] = useState<VisibilityState>({
     boat: true,
@@ -151,7 +146,8 @@ function FleetTable(props: TableProps) {
         accessorKey: "boat",
         id: "boat",
         enableHiding: true,
-        cell: (info) => {
+        cell: (info: any) => {
+          // typing doesn't work in vite
           return (
             <Link href={`/competitors/${info.row.original?.id}`}>
               {info.getValue()}
@@ -165,7 +161,7 @@ function FleetTable(props: TableProps) {
         id: "helmname",
         enableHiding: true,
         header: () => "Skipper",
-        cell: (info) => {
+        cell: (info: any) => {
           return (
             <Link href={`/competitors/${info.row.original?.id}`}>
               {info.getValue()}
@@ -178,7 +174,7 @@ function FleetTable(props: TableProps) {
         accessorKey: "sailno",
         id: "sailno",
         enableHiding: true,
-        cell: (info) => {
+        cell: (info: any) => {
           return (
             <Link href={`/competitors/${info.row.original?.id}`}>
               {info.getValue()}
@@ -192,7 +188,7 @@ function FleetTable(props: TableProps) {
         id: "points",
         enableHiding: false,
         header: () => <Flex justifyContent={"center"}>Points</Flex>,
-        cell: (info) => (
+        cell: (info: any) => (
           <Flex justifyContent={"center"}>
             {info.getValue() !== "" ? parseFloat(info.getValue()) : "---"}
           </Flex>
@@ -204,11 +200,11 @@ function FleetTable(props: TableProps) {
         accessorKey: "elapsed",
         id: "elapsed",
         enableHiding: true,
-        cell: (props) => (
-          <Flex justify={"center"}>{parseFloat(props.getValue())}</Flex>
+        cell: (info: any) => (
+          <Flex justify={"center"}>{parseFloat(info.getValue())}</Flex>
         ),
         footer: (props) => props.column.id,
-        sortingFn: (rowA, rowB, columnId) => {
+        sortingFn: (rowA: any, rowB: any, columnId) => {
           if (rowA.getValue("elapsed") === "---") return 1;
           if (rowB.getValue("elapsed") === "---") return -1;
           if (rowA.getValue("elapsed") < rowB.getValue("elapsed")) return -1;
@@ -220,11 +216,11 @@ function FleetTable(props: TableProps) {
         accessorKey: "corrected",
         id: "corrected",
         enableHiding: true,
-        cell: (props) => (
-          <Flex justifyContent={"center"}>{props.getValue()}</Flex>
+        cell: (info: any) => (
+          <Flex justifyContent={"center"}>{info.getValue()}</Flex>
         ),
         footer: (props) => props.column.id,
-        sortingFn: (rowA, rowB, columnId) => {
+        sortingFn: (rowA: any, rowB: any, columnId) => {
           if (rowA.getValue("corrected") === "---") return 1;
           if (rowB.getValue("corrected") === "---") return -1;
           if (rowA.getValue("corrected") < rowB.getValue("corrected"))
@@ -237,13 +233,13 @@ function FleetTable(props: TableProps) {
         accessorKey: "finish",
         id: "finish",
         enableHiding: true,
-        cell: (props) => (
+        cell: (info: any) => (
           <Flex justify={"center"} m={0}>
-            {props.getValue()}
+            {info.getValue()}
           </Flex>
         ),
         footer: (props) => props.column.id,
-        sortingFn: (rowA, rowB, columnId) => {
+        sortingFn: (rowA: any, rowB: any, columnId) => {
           if (rowA.getValue("finish") === "---") return 1;
           if (rowB.getValue("finish") === "---") return -1;
           if (rowA.getValue("finish") < rowB.getValue("finish")) return -1;
@@ -256,9 +252,9 @@ function FleetTable(props: TableProps) {
         id: "nett",
         enableHiding: true,
         header: () => <Flex justifyContent={"center"}>Nett</Flex>,
-        cell: (props) => (
+        cell: (info: any) => (
           <Flex justify={"center"} m={0}>
-            {props.getValue()}
+            {info.getValue()}
           </Flex>
         ),
         footer: (props) => props.column.id,
@@ -364,7 +360,7 @@ function FleetTable(props: TableProps) {
       <Fragment>
         <Flex justifyContent={"space-between"} px={6}>
           <Flex>
-            <Image src="../../../assets/img/spacer.gif" w={0} height={50} />
+            <Image src={spacer} w={0} height={50} />
             <Heading color="blue.400" size="2xl">
               {fleetName ? fleetName : "Fleet"}
             </Heading>
@@ -423,11 +419,13 @@ function FleetTable(props: TableProps) {
           >
             <Flex justifyContent="space-between">
               <Flex alignItems="center">
-                <Image src="../../../assets/img/spacer.gif" height={8} w={0} />
-                {headerTitle ? (
-                  <Text fontSize="2xl">{headerTitle}</Text>
+                <Image src={spacer} height={8} w={0} />
+                {race ? (
+                  <Text fontSize="2xl">
+                    {race?.name || `Race ${race?.rank}`}
+                  </Text>
                 ) : (
-                  <Spinner size="xs" colorScheme="blue" />
+                  <Spinner size="xs" />
                 )}
                 {isSailed === undefined ||
                 isSailed === "Sailed" ||
@@ -508,7 +506,7 @@ function FleetTable(props: TableProps) {
               {table.getRowModel().rows.map((row) => {
                 return (
                   <Tr key={row.id}>
-                    {row.getVisibleCells().map((cell) => {
+                    {row.getVisibleCells().map((cell: any) => {
                       return (
                         <Td key={cell.id}>
                           {cell.getContext().column.id !== "finish" &&
@@ -519,7 +517,7 @@ function FleetTable(props: TableProps) {
                             )
                           ) : (
                             <Editable
-                              defaultValue={cell.getValue()}
+                              defaultValue={cell.getValue() || null}
                               textAlign="center"
                             >
                               <EditablePreview />
@@ -594,8 +592,10 @@ function FleetTable(props: TableProps) {
                   type="number"
                   size={"xs"}
                   borderRadius={"5px"}
-                  defaultValue={table.getState().pagination.pageIndex + 1}
-                  onChange={(e) => {
+                  defaultValue={(
+                    table.getState().pagination.pageIndex + 1
+                  ).toString()}
+                  onChange={(e: any) => {
                     const page = e.target.value
                       ? Number(e.target.value) - 1
                       : 0;
@@ -608,7 +608,7 @@ function FleetTable(props: TableProps) {
                 size={"xs"}
                 borderRadius={"5px"}
                 value={table.getState().pagination.pageSize}
-                onChange={(e) => {
+                onChange={(e: any) => {
                   table.setPageSize(Number(e.target.value));
                 }}
               >
diff --git a/src/routes/results/components/SettingsModal.tsx b/src/routes/results/components/SettingsModal.tsx
index 9b07958..8f1d653 100644
--- a/src/routes/results/components/SettingsModal.tsx
+++ b/src/routes/results/components/SettingsModal.tsx
@@ -1,5 +1,5 @@
+import { chakra, Box, Flex, Stack, HStack, Divider } from "@chakra-ui/react";
 import {
-  chakra,
   Modal,
   ModalOverlay,
   ModalContent,
@@ -7,28 +7,22 @@ import {
   ModalCloseButton,
   ModalBody,
   ModalFooter,
-  Stack,
-  Divider,
-  Flex,
-  Box,
+} from "@chakra-ui/react";
+import {
   Button,
   Input,
   Radio,
+  RadioGroup,
   FormControl,
   FormErrorMessage,
   FormLabel,
-  ButtonGroup,
-  RadioGroup,
-  useRadio,
-  useColorModeValue,
-  HStack,
 } from "@chakra-ui/react";
+import { useRadio, useColorModeValue } from "@chakra-ui/react";
 import { Fragment, h } from "preact";
 import { StateUpdater, useEffect } from "preact/hooks";
 import { doc, updateDoc } from "firebase/firestore";
 import { db } from "../../../util/firebase-config";
 import { Field, Form, Formik } from "formik";
-import SecBtn from "../../../components/generic/SecBtn";
 import useStorage from "../../../hooks/useStorage";
 
 interface SettingsModalProps {
@@ -223,13 +217,13 @@ function RadioButton(props) {
   return (
     <Fragment>
       <chakra.label {...htmlProps} cursor="pointer">
-        <Input {...getInputProps({})} hidden />
+        <Input {...(getInputProps({}) as any)} hidden />
         <Box
-          {...getCheckboxProps()}
+          {...(getCheckboxProps() as any)}
           //   variant="outline"
           bg={state.isChecked ? "blue" : "gray"}
         >
-          <Box {...getLabelProps()}>{children}</Box>
+          <Box {...(getLabelProps() as any)}>{children}</Box>
         </Box>
       </chakra.label>
     </Fragment>
diff --git a/src/routes/series/Series.tsx b/src/routes/series/Series.tsx
index e734615..3aa6faf 100644
--- a/src/routes/series/Series.tsx
+++ b/src/routes/series/Series.tsx
@@ -1,9 +1,22 @@
-import { Box, Divider, Flex, Heading, Icon, Text, IconButton, Tooltip, useDisclosure } from "@chakra-ui/react";
+import {
+  Box,
+  Divider,
+  Flex,
+  Heading,
+  Icon,
+  Text,
+  IconButton,
+  Tooltip,
+  useDisclosure,
+} from "@chakra-ui/react";
 import { addDoc, collection, query, where } from "firebase/firestore";
 import { Fragment, h } from "preact";
 import { route } from "preact-router";
 import { useCollection } from "react-firebase-hooks/firestore";
-import { FadeInSlideLeft, FadeInSlideRight } from "../../components/animations/FadeSlide";
+import {
+  FadeInSlideLeft,
+  FadeInSlideRight,
+} from "../../components/animations/FadeSlide";
 import { AreYouSure } from "../../components/generic/AreYouSure";
 import useStorage from "../../hooks/useStorage";
 import { db } from "../../util/firebase-config";
@@ -21,7 +34,9 @@ export default function Series(props) {
   setHeaderTitle("Series");
   // Get users series
   const seriesRef = collection(db, "series");
-  const [series, seriesLoading] = useCollection(query(seriesRef, where("__owner", "==", user && user.uid)));
+  const [series, seriesLoading] = useCollection(
+    query(seriesRef, where("__owner", "==", user && user.uid))
+  );
   const deleteSeriesDisclosure = useDisclosure();
 
   // useStorage option (modified to be used as context)
@@ -50,16 +65,22 @@ export default function Series(props) {
     <Fragment>
       <Flex justifyContent="space-between" alignItems="end" px={4}>
         <FadeInSlideRight>
-          <Heading as="h4" color="blue.400">
-            All Series
-          </Heading>
+          <Heading color="blue.400">All Series</Heading>
         </FadeInSlideRight>
 
         {/* Sub header buttons */}
         <FadeInSlideLeft>
           <Flex gap={2}>
-            <ToolIconBtn label="Import file" action={() => route("/import")} icon={FileUploadOutlinedIcon} />
-            <ToolIconBtn label="Add Series" action={addSeriesHandler} icon={AddToPhotosOutlinedIcon} />
+            <ToolIconBtn
+              label="Import file"
+              action={() => route("/import")}
+              icon={FileUploadOutlinedIcon}
+            />
+            <ToolIconBtn
+              label="Add Series"
+              action={addSeriesHandler}
+              icon={AddToPhotosOutlinedIcon}
+            />
           </Flex>
         </FadeInSlideLeft>
       </Flex>
@@ -68,12 +89,21 @@ export default function Series(props) {
 
       <SiteList loading={seriesLoading}>
         {series?.docs.map((series) => (
-          <SiteListItem key={series.id} item={series} disclosure={deleteSeriesDisclosure} listType="series">
+          <SiteListItem
+            key={series.id}
+            item={series}
+            disclosure={deleteSeriesDisclosure}
+            listType="series"
+          >
             <SiteListText
               item={series}
               setStorage={setSeriesId}
               forward="races"
-              textItems={{ head: series.data().event, sub: series.data().venue, foot: series.data().venuewebsite }}
+              textItems={{
+                head: series.data().event,
+                sub: series.data().venue,
+                foot: series.data().venuewebsite,
+              }}
               // data={series}
             >
               <SiteListButtons
@@ -83,7 +113,9 @@ export default function Series(props) {
                 disclosure={deleteSeriesDisclosure}
               >
                 <Box>This will delete the series and is not undo-able</Box>
-                <Box>You will loose any work you have done with this Series</Box>
+                <Box>
+                  You will loose any work you have done with this Series
+                </Box>
               </SiteListButtons>
             </SiteListText>
             {/* {console.log(series.id)} */}
diff --git a/src/routes/series/SeriesEdit.tsx b/src/routes/series/SeriesEdit.tsx
index c4d0ffc..80f084a 100644
--- a/src/routes/series/SeriesEdit.tsx
+++ b/src/routes/series/SeriesEdit.tsx
@@ -38,7 +38,7 @@ import { FadeInSlideRight } from "../../components/animations/FadeSlide";
 import { Starts } from "../races/raceEdit/Starts";
 // Icons
 
-const SeriesEdit = ({ setHeaderTitle }) => {
+export default function SeriesEdit({ setHeaderTitle }) {
   setHeaderTitle("Edit Series");
 
   const [seriesId] = useStorage("seriesId");
@@ -99,7 +99,7 @@ const SeriesEdit = ({ setHeaderTitle }) => {
           <Form>
             <Flex justifyContent="space-between" alignItems="end">
               <FadeInSlideRight>
-                <Heading as="h5" color="blue.400" mx={4}>
+                <Heading color="blue.400" mx={4}>
                   <Editable
                     defaultValue={currentSeries.event}
                     isPreviewFocusable={true}
@@ -107,7 +107,7 @@ const SeriesEdit = ({ setHeaderTitle }) => {
                     <EditablePreview />
                     <EditableInput
                       name="event"
-                      onChange={({ target }) => {
+                      onChange={({ target }: any) => {
                         setSeriesName(target.value);
                       }}
                     />
@@ -121,7 +121,7 @@ const SeriesEdit = ({ setHeaderTitle }) => {
             <Box mb={6} mx={4}>
               <Accordion defaultIndex={[0]}>
                 <AccordionItem>
-                  <Text as={"h2"} mb={3}>
+                  <Text mb={3}>
                     <AccordionButton>
                       <Box flex="1" textAlign="left">
                         Series details
@@ -275,7 +275,7 @@ const SeriesEdit = ({ setHeaderTitle }) => {
                 </AccordionItem>
 
                 <AccordionItem>
-                  <Text as={"h2"} mb={3}>
+                  <Text mb={3}>
                     <AccordionButton>
                       <Box flex="1" textAlign="left">
                         Venue details
@@ -305,7 +305,7 @@ const SeriesEdit = ({ setHeaderTitle }) => {
                 </AccordionItem>
 
                 <AccordionItem>
-                  <Text as={"h2"} mb={3}>
+                  <Text mb={3}>
                     <AccordionButton>
                       <Box flex="1" textAlign="left">
                         File properties
@@ -348,6 +348,6 @@ const SeriesEdit = ({ setHeaderTitle }) => {
       )}
     </Fragment>
   );
-};
+}
 
-export default SeriesEdit;
+// export default SeriesEdit;
diff --git a/src/routes/signin/index.tsx b/src/routes/signin/index.tsx
index 0b6ad0d..06c38ed 100644
--- a/src/routes/signin/index.tsx
+++ b/src/routes/signin/index.tsx
@@ -4,7 +4,7 @@ import { auth } from "../../util/firebase-config";
 import { SignIn } from "../../components/page/SignIn";
 import { SignOut } from "../../components/page/SignOut";
 
-const Unauthed = () => {
+export default function Unauthed() {
   const [user] = useAuthState(auth);
 
   return (
@@ -13,6 +13,6 @@ const Unauthed = () => {
       {!user ? <SignIn /> : <SignOut />}
     </div>
   );
-};
+}
 
-export default Unauthed;
+// export default Unauthed;
diff --git a/src/routes/user/UserLanding.tsx b/src/routes/user/UserLanding.tsx
index 1da2fe8..efc5660 100644
--- a/src/routes/user/UserLanding.tsx
+++ b/src/routes/user/UserLanding.tsx
@@ -1,23 +1,16 @@
 import { Fragment, h } from "preact";
 import { Box, Container, Heading } from "@chakra-ui/react";
-import { FadeInSlideRight, FadeIn } from "../../components/animations/FadeSlide";
+import {
+  FadeInSlideRight,
+  FadeIn,
+} from "../../components/animations/FadeSlide";
 
-const UserLanding = () => {
+export default function UserLanding() {
   return (
     <Fragment>
       <Container>
         <FadeInSlideRight>
-          <Heading
-            as="h3"
-            color="blue.400"
-            // position={"fixed"}
-            w="100%"
-            mt={2}
-            pb={3}
-            // height={"20px"}
-            // bg={"white"}
-            // zIndex="+1"
-          >
+          <Heading color="blue.400" w="100%" mt={2} pb={3}>
             User area
           </Heading>
         </FadeInSlideRight>
@@ -27,5 +20,5 @@ const UserLanding = () => {
       </Container>
     </Fragment>
   );
-};
-export default UserLanding;
+}
+// export default UserLanding;
diff --git a/src/routes/user/UserProfile.tsx b/src/routes/user/UserProfile.tsx
index aedafe7..edc068b 100644
--- a/src/routes/user/UserProfile.tsx
+++ b/src/routes/user/UserProfile.tsx
@@ -1,13 +1,25 @@
 import { h } from "preact";
-import { Box, Button, Container, Divider, FormLabel, Heading, Input, useToast } from "@chakra-ui/react";
+import {
+  Box,
+  Button,
+  Container,
+  Divider,
+  FormLabel,
+  Heading,
+  Input,
+  useToast,
+} from "@chakra-ui/react";
 import { doc, updateDoc } from "firebase/firestore";
 import { auth, db } from "../../util/firebase-config";
 import { useAuthState } from "react-firebase-hooks/auth";
 import { useDocumentData } from "react-firebase-hooks/firestore";
 import { Field, Form, Formik } from "formik";
-import { FadeIn, FadeInSlideRight } from "../../components/animations/FadeSlide";
+import {
+  FadeIn,
+  FadeInSlideRight,
+} from "../../components/animations/FadeSlide";
 
-const UserProfile = () => {
+export default function UserProfile() {
   const submittedToast = useToast();
   const [user, userLoading] = useAuthState(auth);
 
@@ -16,7 +28,9 @@ const UserProfile = () => {
 
   const submitHandler = async (values: any) => {
     // remove undefined's from values
-    Object.keys(values).forEach((key) => (values[key] === undefined ? delete values[key] : {}));
+    Object.keys(values).forEach((key) =>
+      values[key] === undefined ? delete values[key] : {}
+    );
 
     await updateDoc(docRef, values);
 
@@ -35,7 +49,7 @@ const UserProfile = () => {
   return (
     <Container>
       <FadeInSlideRight>
-        <Heading as="h3" color="blue.400" w="100%" mt={2} pb={3}>
+        <Heading color="blue.400" w="100%" mt={2} pb={3}>
           Profile
         </Heading>
       </FadeInSlideRight>
@@ -94,5 +108,5 @@ const UserProfile = () => {
       </FadeIn>
     </Container>
   );
-};
-export default UserProfile;
+}
+// export default UserProfile;
diff --git a/src/routes/user/UserSettings.tsx b/src/routes/user/UserSettings.tsx
index 09be246..013df9d 100644
--- a/src/routes/user/UserSettings.tsx
+++ b/src/routes/user/UserSettings.tsx
@@ -19,10 +19,13 @@ import { doc, updateDoc } from "firebase/firestore";
 import { Field, Form, Formik } from "formik";
 import { useAuthState } from "react-firebase-hooks/auth";
 import { useDocumentData } from "react-firebase-hooks/firestore";
-import { FadeIn, FadeInSlideRight } from "../../components/animations/FadeSlide";
+import {
+  FadeIn,
+  FadeInSlideRight,
+} from "../../components/animations/FadeSlide";
 import { auth, db } from "../../util/firebase-config";
 
-const UserSettings = () => {
+export default function UserSettings() {
   const submittedToast = useToast();
   const [user, userLoading] = useAuthState(auth);
   const docRef = doc(db, "user", user!.uid); // bang
@@ -64,7 +67,7 @@ const UserSettings = () => {
     <Fragment>
       <Container>
         <FadeInSlideRight>
-          <Heading as="h3" color="blue.400" w="100%" mt={2} pb={3}>
+          <Heading color="blue.400" w="100%" mt={2} pb={3}>
             Settings
           </Heading>
         </FadeInSlideRight>
@@ -81,17 +84,40 @@ const UserSettings = () => {
               <Form>
                 <Field name="defaultResultType">
                   {({ field, form }) => (
-                    <FormControl isInvalid={form.errors.name && form.touched.name}>
-                      <FormLabel htmlFor="defaultResultType">Default scoring type</FormLabel>
-                      <RadioGroup {...field} id="defaultResultType" colorScheme="blue">
+                    <FormControl
+                      isInvalid={form.errors.name && form.touched.name}
+                    >
+                      <FormLabel htmlFor="defaultResultType">
+                        Default scoring type
+                      </FormLabel>
+                      <RadioGroup
+                        {...field}
+                        id="defaultResultType"
+                        colorScheme="blue"
+                      >
                         <HStack>
-                          <Field type="radio" name="defaultResultType" value="position" as={Radio}>
+                          <Field
+                            type="radio"
+                            name="defaultResultType"
+                            value="position"
+                            as={Radio}
+                          >
                             Position
                           </Field>
-                          <Field type="radio" name="defaultResultType" value="elapsed" as={Radio}>
+                          <Field
+                            type="radio"
+                            name="defaultResultType"
+                            value="elapsed"
+                            as={Radio}
+                          >
                             Elapsed
                           </Field>
-                          <Field type="radio" name="defaultResultType" value="finish" as={Radio}>
+                          <Field
+                            type="radio"
+                            name="defaultResultType"
+                            value="finish"
+                            as={Radio}
+                          >
                             Finishes
                           </Field>
                         </HStack>
@@ -127,5 +153,5 @@ const UserSettings = () => {
       </Container>
     </Fragment>
   );
-};
-export default UserSettings;
+}
+// export default UserSettings;
diff --git a/src/style/index.css b/src/style/index.css
index 3e44ae9..83d8d5e 100644
--- a/src/style/index.css
+++ b/src/style/index.css
@@ -32,6 +32,11 @@ h3 {
   /* margin-inline: auto; */
   /* min-height: 100%; */
 } 
+.firebase-emulator-warning{
+  display: hidden !important;
+
+  background: transparent
+}
 
 
 
diff --git a/src/util/AuthenticatedRoute .tsx b/src/util/AuthenticatedRoute .tsx
index 8d8ba11..c34cdec 100644
--- a/src/util/AuthenticatedRoute .tsx	
+++ b/src/util/AuthenticatedRoute .tsx	
@@ -4,13 +4,19 @@ import { useAuthState } from "react-firebase-hooks/auth";
 import { auth } from "./firebase-config";
 import Unauthed from "../routes/signin";
 
-export const AuthRoute = ({ component: C, ...props }) => {
+export function AuthRoute({ component: C, ...props }) {
   const [user] = useAuthState(auth);
   return (
     <Route
       {...props}
-      component={(routeProps) => (user ? <C {...routeProps} /> : <Route path="/signin" component={Unauthed} />)}
+      component={(routeProps) =>
+        user ? (
+          <C {...routeProps} />
+        ) : (
+          <Route path="/signin" component={Unauthed} />
+        )
+      }
     />
   );
-};
+}
 //
diff --git a/tsconfig.json b/tsconfig.json
index da29c4b..9898f6e 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,15 +1,12 @@
 {
   "compilerOptions": {
     "target": "ESNext",
-    "useDefineForClassFields": true,
     "lib": ["DOM", "DOM.Iterable", "ESNext"],
     "allowJs": false,
     "skipLibCheck": true,
     "esModuleInterop": true,
-    "allowSyntheticDefaultImports": true,
     "strict": true,
     "noImplicitAny": false, 
-    "forceConsistentCasingInFileNames": true,
     "module": "ESNext",
     "moduleResolution": "Node",
     "resolveJsonModule": true,
@@ -23,4 +20,4 @@
   },
   "include": ["src"],
   "references": [{ "path": "./tsconfig.node.json" }]
-}
+}
\ No newline at end of file
diff --git a/vite.config.ts b/vite.config.ts
index e3bdaff..7737794 100644
--- a/vite.config.ts
+++ b/vite.config.ts
@@ -1,7 +1,19 @@
 import { defineConfig } from 'vite'
 import preact from '@preact/preset-vite'
+import { VitePWA } from 'vite-plugin-pwa'
 
 // https://vitejs.dev/config/
 export default defineConfig({
-  plugins: [preact()]
+  plugins: [
+    preact(),
+  //   VitePWA({ 
+  //     registerType: 'autoUpdate',
+  //     devOptions: {
+  //       enabled: true
+  //     },
+  //     workbox: {
+  //       globPatterns: ['**/*.{js,css,html,ico,png,svg}']
+  //     }
+  // })
+  ]
 })
